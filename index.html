<!DOCTYPE html>
<html>
<head>
    <title>Relativity&#39;s Reach</title>
    <link href="css/jquery-ui.v1.11.4.css" rel="stylesheet">
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="css/introjs.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
</head>
<body>
<div id="canvas-align">
    <div id="ThreeJS"></div>

    <div id="hud" class="visible">
        <div id = "loader"></div>
        <div id="header" alt="Relativity's Reach"></div>
        <div class="wrapper">
            <h2 class="wrapper-title">Views</h2>
            <div id="keyInfo" class="noselect">
                <div id="navButtons" class="noselect">
                    <button id="topView" onclick="topView();">TOP VIEW</button>
                    <button id="sideView" onclick="sideView();">SIDE VIEW</button>
                    <button id="resetView" onclick="resetView();">RESET</button>
                    <button id="introTour" onclick="startIntro();">TOUR</button>
                </div>
            </div>
        </div>
        <div class="wrapper-nav">
            <div><h2 class="wrapper-title">Navigation</h2></div>
            <div id="navInstructions" class="noselect">
                <div id="navInfo">
                    <span id="orbit">Orbit: left mouse / touch: one finger move</span>
                    <br><span id="zoom">Zoom: mousewheel / touch: two finger spread or squish</span>
                    <br><span id="pan">Pan: right mouse, or arrow keys / touch: two finger drag</span>
                </div>
                
            </div>
        </div>
        <div class="wrapper-legend">
            <div><h2 class="wrapper-title">Legend</h2></div>
            <div id="authorKey" class="noselect">
                <div>
                    <div id="circle_author1" class="circle"></div><span class="circle_info">&nbsp; 1 author</span>
                </div>
                <div>
                    <div id="circle_author2" class="circle"></div><span class="circle_info">&nbsp; 2 authors</span>
                </div>
                <div>
                    <div id="circle_author3" class="circle"></div><span class="circle_info">&nbsp; 3 authors</span>
                </div>
                <div>
                    <div id="circle_author4" class="circle"></div><span class="circle_info">&nbsp; 4 authors</span>
                </div>
                <div>
                    <div id="circle_author5" class="circle"></div><span class="circle_info">&nbsp; 5 - 849 authors</span>
                </div>
                <div>
                    <div id="circle_author6" class="circle"></div><span class="circle_info">&nbsp; 850+ authors</span>
                </div>
                <br>
                <div>
                    <div id="circle_pub" class="circle"></div><span class="circle_info">&nbsp; Currently published</span>
                </div>
                <div>
                    <div id="circle_unpub" class="circle"></div><span class="circle_info">&nbsp; Awaiting peer review</span>
                </div>
                <br>
                <div>
                    <span class="circle_info">Smallest dot: no citations</span>

                </div>
                <div>
                    <br>
                     <span class="circle_info">Largest dot: 85 citations</span>
                </div>
            </div> 
        </div>

        <div id="UI">
            <div id="keyword-container" class="noselect">
                <h2 style="padding-left: 5px;">Concept Keywords</h2>
                <p id="tagline">(Most frequently used)</p>
                <ol id="selectable">
                    <li class="ui-widget-content">Black hole</li>
                    <li class="ui-widget-content">Physical cosmology</li>
                    <li class="ui-widget-content">String theory</li>
                    <li class="ui-widget-content">Gravitation</li>
                    <li class="ui-widget-content">Dark matter</li>
                    <li class="ui-widget-content">Spacetime</li>
                    <li class="ui-widget-content">Special relativity</li>
                    <li class="ui-widget-content">Time</li>
                    <li class="ui-widget-content">Quantum gravity</li>
                    <li class="ui-widget-content">Gravitational wave</li>
                    <li class="ui-widget-content">Big bang</li>
                    <li class="ui-widget-content">Standard model</li>
                    <li class="ui-widget-content">Hawking radiation</li>
                    <li class="ui-widget-content">Dark energy</li>
                    <li class="ui-widget-content">Symmetry</li>
                </ol>
            </div>
        </div>

    </div>

    <div id="articleInfo" class="visible">
        <div><span id="title" ></span></div>
        <div><span id="authors" ></span></div>
        <div><span id="citations" ></span></div>
        <div><span id="articleUrl"><a href="" target="_blank"></a></span></div>
    </div>
</div>
<script type="text/javascript" src="js/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="js/jquery-ui.v1.11.4.min.js"></script>
<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/OrbitControls.js"></script>
<script type="text/javascript" src="js/tween.min.js"></script>
<script type="text/javascript" src="js/Detector.js"></script>
<script type="text/javascript" src="js/stats.min.js"></script>
<script type="text/javascript" src="js/intro.js"></script>
<script type="text/javascript" src="js/jquery.scrollto.min.js"></script>

<script type="x-shader/x-vertex" id="vertexshader">
    //for spline object - have transparency
    attribute vec3 customColor;
    attribute float customOpacity;

    varying vec3 vColor;
    varying float vOpacity;

    void main() {
        vColor = customColor;
        vOpacity = customOpacity;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    //for spline object - have transparency
    varying vec3 vColor;
    varying float vOpacity;

    void main() {
        gl_FragColor = vec4( vColor, vOpacity);
    }
</script>

<script type="x-shader/x-vertex" id="circleVertexShader">   
    varying vec2 vUV;
    void main() {
        vUV = position.xy;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
</script>

<script type="x-shader/x-fragment" id="circleFragmentShader">
    uniform vec3 innerCol;
    uniform vec3 strokeCol;
    uniform float radius;
    uniform float stroke;

    varying vec2 vUV;


    void main() {
        float dist = distance(vUV, vec2(radius / 2.0, radius / 2.0));
        float circleRadius = radius / 2.0;
        float borderRadius = circleRadius - stroke / 2.0;

        if (dist < circleRadius && dist > borderRadius) {
            gl_FragColor = vec4(strokeCol, 1.0);
        }
        else if (dist < circleRadius) {
            gl_FragColor = vec4(innerCol, 1.0);
        }
        else {
            discard;
        }
    }
</script>

<script>
    var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    //var isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);

    if (!isChrome) {
        console.log("For best viewing results, please load this visualization in Google Chrome or another WebGL enabled browser");
        // console.log("BROWSER NOT CHROME");
    }
    //standard global variables
    var container, scene, camera, renderer, controls, raycaster, mouse, composer, stats;
    var cameraOrtho, sceneOrtho;
    var mouse = { x: 0, y: 0 };
    var INTERSECTED, INTERSECTED_TERMS;
    var SCREEN_WIDTH, SCREEN_HEIGHT;

    //custom global variables
    var mesh;

    //data global variables
    var articles = [];
    var terms = [];

    var articleObjects = [];
    var termObjects = [];
    var termObj;
    var articleObj;
    var splineObj;
    var spriteObj;
    var frequentKeywords = ["Black hole", "Physical cosmology", "String theory", "Gravitation", "Dark matter", "Spacetime", "Special relativity", "Time", "Quantum gravity", "Gravitational wave", "Big bang", "Standard model", "Hawking radiation" , "Dark energy", "Symmetry"];
    //shader variables
    var attributes;

    var selectedArticles = [];

    var tourActive = false;
    var sideViewActive = false;
    var navViewActive = false;

    var termOffset = 0;
    var labelDistThreshold = 4000;
    var frequentLabelThresh = 2000;
    var termPosGridLevel = 0;
    var termPosAboveGrid = 250;
    var termPosLower = -1500;

    var eyeTargetScale;

    init();

    function startIntro(){
        var intro = introJs();

        intro.setOptions({
            steps: [
                {
                    intro: "<h2>Relativity's Reach</h2><br>This interactive graphic visualizes the impact of the general theory of relativity on current physics research a hundred years after Albert Einstein first described how gravity emerges from the bending of spacetime.<br><br>Data on the modern research trends comes from arXiv.org, an online database of scientific papers."
                },
                {
                    intro: "<h2>Data Source</h2><br>Each colored dot represents a paper uploaded in 2014 to the arXiv.org database. Each paper has been classified as having 'General Relativity&ndash;Quantum Cosmology' as its main category &ndash; a total of 2,435 papers.<br><br>Use your mouse to roll over an article and reveal its title, authors, and number of citations by other researchers (a mark of the paper's influence). Right (or CTRL) clicking on the article dot when highlighted opens a new window to the article's page on arXiv.org."
                },
                {
                    intro: "<h2>Concept Keywords</h2><br>A powerful text analysis tool, which is now part of IBM's Watson AI system, examined the abstracts of all 2,435 papers in the General Relativity&ndash;Quantum Cosmology category and identified keywords for critical concepts within those papers. Scientific American then edited them for relevancy, leaving 61 keywords. The 15 most used ones are listed on the left in order of frequency.<br><br>You may select a keyword to see which articles reference it. Select multiple keywords by dragging over multiple buttons or selecting while pressing the CTRL key."
                },
                {
                    intro: "<h2>Article and Keyword Layout</h2><br>Article dots are positioned near keywords (red diamonds). If the article has multiple keywords, the dot is placed between terms, such as the article with both antimatter and gravitation keywords."
                },
                {
                    intro: "<h2>Citations</h2><br>The size of the dot is based on how often the 2014 article has been cited since publication through the middle of 2015. The smallest dot corresponds to a paper with no citations whereas the largest dot has 85 citations."
                },
                {
                    intro: "<h2>Publication Status</h2><br>The colored circle around each dot indicates publication status. Many physicists put their papers on arXiv before they are published. Articles with a bright blue outline have been published whereas articles circled in dark purple are awaiting peer review (as of June, 2015)."
                },
                {
                    intro: "<h2>Authors</h2><br>The number of authors per article generally varies between one and five. In some cases, like the LIGO research (red dot in center), there are over 850 authors for a single article."
                },
                {
                    intro: "<h2>Key</h2><br>The color of the dot indicates number of authors.<br>The color of the dot's outline indicates the publication status.<br>The size of the dot indicates the number of citations."
                },
                {
                    intro: "<h2>Navigation</h2><br>You may explore the visualization by using your mouse to tour around the scene.<br><br>Tour: left mouse / touch: one finger move<br>Zoom: mousewheel / touch: two finger spread or squish<br>Pan: right mouse, or arrow keys / touch: two finger drag<br><br>You can also select various views to focus on the top or sides of the graphic. Select the tour to replay this introduction."
                }
            ],
            skipLabel: 'Exit',
            tooltipPosition: 'bottom',
            exitOnOverlayClick: true,
            showStepNumbers: false,
            overlayOpacity: 0.1
        });

        intro.onchange(function(targetElement, currentStep) {
            //console.log("Current Scene: " + intro._currentStep);
            var introTweenOptions = {duration: 1000, easing: TWEEN.Easing.Quadratic.InOut};
            if (sideViewActive) sideViewActive = false;
            
            switch(intro._currentStep) { 
                case 0: //INTRO SCREEN
                    tourActive = true;
                    moveTermsToStartPos();
                    moveAndLookAt(camera, new THREE.Vector3(580, 1390, 1600), new THREE.Vector3(435, -430, 560), introTweenOptions);
                    break;

                case 1: //Data Source - explains article rollover behavior
                    turnOffSpline( "physical cosmology" );
                    moveAndLookAt(camera, new THREE.Vector3(1350, 500, 1200), new THREE.Vector3(925, -1170, 75), introTweenOptions);
                    break;

                case 2: //Concept Keywords - shows how to highlight articles
                    moveAndLookAt(camera, new THREE.Vector3(130, 550, 2670), new THREE.Vector3(530, -570, 165), introTweenOptions);
                    //highlight physical cosmology (in moveTermsDown function)
                    moveTermsDown();
                    
                    break;

                case 3: //Article and Keyword Layout
                    moveAndLookAt(camera, new THREE.Vector3(62, 750, 195 + 1e-10), new THREE.Vector3(62, 33, 195), introTweenOptions);
                    moveTermsUp();
                    turnOffSpline("physical cosmology");
                    break;

                case 4: //Citations
                    moveTermsToStartPos();
                    moveAndLookAt(camera, new THREE.Vector3(740, 300, 1111), new THREE.Vector3(485, -575, -190), introTweenOptions);
                    break;

                case 5: //Publication status
                    moveAndLookAt(camera, new THREE.Vector3(1146, 205, 633), new THREE.Vector3(600, -663, -143), introTweenOptions);
                    break;

                case 6: //Authors
                    moveAndLookAt(camera, new THREE.Vector3(675, 330, 675), new THREE.Vector3(30, -1300, 690), introTweenOptions);
                    break;

                case 7: //Key (wide view)
                    navViewActive = false;
                    moveAndLookAt(camera, new THREE.Vector3(450, 3500, 890 + 1e-10), new THREE.Vector3(450, 0, 890), introTweenOptions);
                    break;

                case 8: //Navigation
                    var str = "http://arxiv.org/abs/1403.5306v2";
                    var objlookAt = articleObj.getObjectByName(str);
                    //console.log(objlookAt);
                    navViewActive = true;
                    moveTermsDown();
                    moveAndLookAt(camera, new THREE.Vector3(objlookAt.position.x + 700, objlookAt.position.y, objlookAt.position.z + 700), objlookAt.position, introTweenOptions);
                    break;
            }
        });

        intro.onexit(function() {
            //console.log("Intro completed");
            tourActive = false;
            navViewActive = false;
            topView();
        });

        intro.oncomplete(function() {
            //console.log("Intro completed");
            tourActive = false;
            navViewActive = false;
            topView();
        });

        intro.start();
    }

    function init() {
        //SCENE
        scene = new THREE.Scene();
        sceneOrtho = new THREE.Scene();

        termObj = new THREE.Object3D();
        splineObj = new THREE.Object3D();
        articleObj = new THREE.Object3D();
        spriteObj = new THREE.Object3D();

        scene.add( termObj );
        scene.add( splineObj );
        scene.add( articleObj );
        scene.add( spriteObj );

        //CAMERA
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;
        // SCREEN_WIDTH = 960;
        // SCREEN_HEIGHT = 680;
        var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 10, FAR = 10000;

        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set (-1345, 1250, 2865);
        camera.lookAt(250, -680, 930);
        scene.add(camera);

        //RENDERER
        if (Detector.webgl) {
            renderer = new THREE.WebGLRenderer( {antialias: true} );
        } else {
            console.log("using canvas renderer... slow");
            renderer = new THREE.CanvasRenderer();
        }
        
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

        container = document.getElementById( 'ThreeJS' );
        document.body.appendChild(container);
        container.appendChild( renderer.domElement );

        //EVENTS
        controls = new THREE.OrbitControls( camera,  renderer.domElement );
        controls.maxDistance = 7000;
        controls.target.set( 250, -680, 930 );

        var startdir = new THREE.Vector3();
        startdir.subVectors( camera.position, controls.target );
        eyeTargetScale = Math.tan(camera.fov * (Math.PI/180) / 2) * startdir.length();

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        //LIGHT
        var light = new THREE.PointLight( 0xFFFFFF );
        light.position.set(100, 2050, 100);

        var bottomLight = new THREE.PointLight( 0xFFFFFF );
        light.position.set(100, -2000, 100);

        scene.add(bottomLight);
        scene.add(light);

        //LOADING DATA
        loadArticles();

        ////////////
        // CUSTOM //
        ////////////
        var isMobile = {
            Android: function() {
                return navigator.userAgent.match(/Android/i);
            },
            BlackBerry: function() {
                return navigator.userAgent.match(/BlackBerry/i);
            },
            iOS: function() {
                return navigator.userAgent.match(/iPhone|iPad|iPod/i);
            },
            Opera: function() {
                return navigator.userAgent.match(/Opera Mini/i);
            },
            Windows: function() {
                return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
            },
            any: function() {
                return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
            }
        };

        if( isMobile.any() ) {
            console.log('Mobile');
            $("#navInstructions").css({ 'width': '165px'});
            $("#orbit").text("Orbit:  one finger move");
            $("#zoom").text("Zoom:  two finger spread or squish");
            $("#pan").text("Pan:  two finger drag");
        } else {
            $("#navInstructions").css({ 'width': '150px'});
            $("#orbit").text("Orbit: left mouse");
            $("#zoom").text("Zoom:  mousewheel");
            $("#pan").text("Pan:  right mouse, or arrow keys");
        }
            

        // stats = new Stats();
        // stats.domElement.style.position = 'absolute';
        // stats.domElement.style.bottom = '0px';
        // stats.domElement.style.left = '0px';
        // container.appendChild( stats.domElement );

        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseup', onMouseUp, false);
        window.addEventListener('mousedown', onMouseDown, false);
        window.addEventListener( 'resize', onWindowResize, false );

        $(window).keypress(function(e) {
            if (e.keyCode === 0 || e.keyCode === 32) {
                //console.log('Space pressed');
                saveCamera();
            }
        });

        // kick off the renderer
        render();
    }

    function saveCamera() {
        console.log("Saving Camera");
        console.log(camera.position);
        console.log(camera.rotation);
        //console.log(camera.quaternion);
        console.log(controls.center);
        console.log("articles");
        console.log(articleObjects[0].rotation);
        console.log(articleObjects[0].quaternion);

        var grid = scene.getObjectByName("lowerGrid");
        console.log(grid.position);
    }

    function bottomView() {
        //console.log("bottomView");
        if (sideViewActive) sideViewActive = false;

        var grid = scene.getObjectByName("lowerGrid");
        moveAndLookAt(camera, new THREE.Vector3( grid.position.x - 225, grid.position.y - 3000, grid.position.z + 200 + 1e-10), new THREE.Vector3(grid.position.x - 225, grid.position.y, grid.position.z + 200), {
            duration: 1000,
            easing: TWEEN.Easing.Quadratic.InOut
        });
    }

    function resetView() {
        //console.log("resetView");
        if (sideViewActive) sideViewActive = false;

        moveTermsToStartPos();

        moveAndLookAt(camera, new THREE.Vector3( 265, 2000, 750 + 1e-10), new THREE.Vector3(265, 0, 750), {
            duration: 1000,
            easing: TWEEN.Easing.Quadratic.InOut
        });
    }

    function topView() {
        //console.log("topView");
        if (sideViewActive) sideViewActive = false;

        moveTermsUp();

        moveAndLookAt(camera, new THREE.Vector3( 265, 3500, 750 + 1e-10), new THREE.Vector3(265, 0, 750), {
            duration: 1000,
            easing: TWEEN.Easing.Quadratic.InOut
        });
    }

    function sideView() {
        //console.log("sideView");
        sideViewActive = true;

        moveTermsDown();
        
        moveAndLookAt(camera, new THREE.Vector3( 400, -320, 4100), new THREE.Vector3(350, -860, 920), {
            duration: 1000,
            easing: TWEEN.Easing.Quadratic.InOut
        });
    }

    function turnOnSplines() {
        $("#selectable li").each(function(index) {
            //console.log(index + ": " + $( this ).text());
            var concept = $(this).text().toLowerCase();
            var selected = termObj.getObjectByName(concept);

            //set highlight of selected articles and draw splines to selected terms
            for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                var index = selected.userData.articleIndices[k];
                articleObjects[index].material.uniforms.innerCol.value = new THREE.Color ( 0xFFFCC7 );
                articleObjects[index].userData.clicked = true;

                if (k % 2 === 0) {
                    drawSplines ( articleObjects[index], selected, concept );
                }
            }

            splineObj.name = concept;
            scene.add(splineObj);
            selectSelectableElement($("#selectable"), $("#selectable li") );
        });
    }

    function turnOnSpline( key ) {
        var selected = termObj.getObjectByName(key);

        //set highlight of selected articles and draw splines to selected terms
        for (var k = 0; k < selected.userData.articleIndices.length; k++) {
            var index = selected.userData.articleIndices[k];

            articleObjects[index].material.uniforms.innerCol.value = new THREE.Color ( 0xFFFCC7 );
            articleObjects[index].userData.clicked = true;

            if (k % 2 === 0) {
                drawSplines ( articleObjects[index], selected, key );
            }
        }

        splineObj.name = key;
        scene.add( splineObj );
        selectSelectableElement($("#selectable"), $("#selectable li:eq(1)"));
    }

    function turnOffSpline( key ) {
        unselectSelectableElement($("#selectable"));
        if( splineObj.children.length > 0 ) {
            for ( s in splineObj.children) {
                splineObj.remove(s);
            }
            scene.remove(splineObj);
            var selected = termObj.getObjectByName(key);
            for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                var index = selected.userData.articleIndices[k];
                //console.log(articleObjects[index].userData.id);
                articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                articleObjects[index].userData.clicked = false;
            }
        }
    }

    function turnOffSplines() {
        $("#selectable li").each(function(index) {
            //console.log(index + ": " + $( this ).text());
            var concept = $(this).text().toLowerCase();
            var selected = termObj.getObjectByName(concept);

            //set highlight of selected articles and draw splines to selected terms
            for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                var index = selected.userData.articleIndices[k];
                articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                articleObjects[index].userData.clicked = false;
            }

            var splineHolder = splineObj.getObjectByName(concept);
            if (splineHolder != undefined) {
                //remove splines that were previously created
                for (var i = splineHolder.children.length - 1; i >= 0; i--) {
                    //console.log(splineHolder.children[i]);
                    splineObj.remove(splineHolder.children[i]);
                }
                scene.remove(splineObj);
            }
            unselectSelectableElement($("#selectable"), $("#selectable li") );
        });
    }

    // Camera Tweening
    // Better just to save and pass quaternion?
    // This seems like the definitive issue thread on the top-axis flip issue
    // https://github.com/mrdoob/three.js/issues/1460
    function moveAndLookAt(camera, dstpos, dstlookat, options) {
        options || (options = {duration: 300, easing: TWEEN.Easing.Linear.None});

        var origpos = new THREE.Vector3().copy(camera.position); // original position
        var origrot = new THREE.Euler().copy(camera.rotation); // original rotation
        //console.log("origrot: " + origrot);

        camera.position.set(dstpos.x, dstpos.y, dstpos.z);
        camera.lookAt(dstlookat);
        var dstrot = new THREE.Euler().copy(camera.rotation);

        // Restore original position and rotation
        camera.position.set(origpos.x, origpos.y, origpos.z);
        camera.rotation.set(origrot.x, origrot.y, origrot.z);

        // Tween Camera
        // rotation (using slerp)
        (function () {
            var origQuat = new THREE.Quaternion().copy(camera.quaternion);
            var destQuat = new THREE.Quaternion().setFromEuler(dstrot);
            var lerpQuat = new THREE.Quaternion();
            var lerpPos = new THREE.Vector3();

            var o = {t: 0};
            new TWEEN.Tween(o).to({t: 1}, options.duration).easing(options.easing).onUpdate(function () {
                // Position
                lerpPos.lerpVectors(origpos, dstpos, o.t);
                camera.position.copy(lerpPos);

                // Rotation
                THREE.Quaternion.slerp(origQuat, destQuat, lerpQuat, o.t);
                camera.quaternion.copy(lerpQuat);
            }).onComplete(function () {
                // Update camera target
                controls.target.copy(dstlookat);
                controls.update();
            }).start();
        }).call(this);
    }

    // 60 hz
    function render() {
        //stats.begin();
        TWEEN.update();
        //console.log(controls.minDistance);

        //if we've drawn the grid
        if (scene.getObjectByName("lowerGrid")) {
            var grid = scene.getObjectByName("lowerGrid");

            var dist;
            dist = camera.position.distanceTo( grid.position );
            //console.log(dist);
            //var scalar = 1000/dist; 
            var inverseScalar = dist/(1000 * 2.8);
            //console.log(scalar);
            //console.log(inverseScalar);
            //sprite labels should only appear when close enough to read
            if (spriteObj != undefined && spriteObj.children.length > 60) {
                var spr = scene.getObjectByName("sprites");
                //console.log(spr);
                var term = scene.getObjectByName("terms");
                
                if (dist > labelDistThreshold) {
                    //turn off labels                   
                    //spr.visible = false;
                    for (var i = 0; i < spr.children.length; i++) {
                        spr.children[i].visible = false;
                    }
                } else if (dist > frequentLabelThresh && dist < labelDistThreshold) {
                    for (var i = 0; i < spr.children.length; i++) {
                        var name = spr.children[i].name;
                        if (spr.children[i].userData.frequent) {
                            spr.children[i].visible = true;
                        } else {
                            spr.children[i].visible = false;
                        }  
                    }  
                    //spr.visible = true;
                } else if (dist < frequentLabelThresh ) {
                    for (var i = 0; i < spr.children.length; i++) {
                        spr.children[i].visible = true;
                    }
                    //spr.visible = true;
                }
                
                if(inverseScalar > 1.5) inverseScalar = 1.5;
                if(inverseScalar < 0.2) inverseScalar = 0.2;
                
                for (var i = 0; i < term.children.length; i++) {
                    term.children[i].scale.set(inverseScalar, inverseScalar, inverseScalar );
                }

                for (var i = 0; i < spr.children.length; i++) {
                    spr.children[i].scale.set(inverseScalar, inverseScalar, inverseScalar);
                }  
            }
        }

        if (tourActive) {
            controls.minDistance = 0;
            //controls.update();
        } else {
            controls.minDistance = 300;
            //controls.update();
        }

        //composer.render();
        renderer.render( scene, camera );
        //stats.end();
        requestAnimationFrame(render);

    }

    function onMouseDown( event ) {
        //console.log("MOUSE DOWN");
        //console.log("tourActive is: " + tourActive);

        mouse.x = (event.clientX / renderer.domElement.width) * window.devicePixelRatio * 2 - 1;
        mouse.y = ((event.clientY / renderer.domElement.height) * window.devicePixelRatio * 2 - 1) * -1;

        raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects( articleObjects );

        if (intersects.length > 0) {
            //don't open article new window if clicking on UI elements
            if($('#selectable').is(':hover') || $('#navButtons').is(':hover') || $('#navInstructions').is(':hover') || $('#authorKey').is(':hover') || $('#header').is(':hover')) {
                //console.log("over the term menu");
            } else if (tourActive && $('.introjs-tooltip:first').is(':hover')) {
                //console.log("over the term menu");
            } else {
                //opens new tab with article page
                if(event.which === 3) { //only opens on right click
                    window.open(intersects[0].object.userData.id);
                }
            }

            //disabled camera movement to point on click - but could be a good interface?
            //moveAndLookAt(camera, new THREE.Vector3(intersects[0].object.position.x, intersects[0].object.position.y + 50, intersects[0].object.position.z + 100), intersects[0].object.position, {duration: 1000});
        }
    }

    function selectSelectableElement (selectableContainer, elementsToSelect) {
        // console.log("selecting: ");
        // console.log(elementsToSelect);
        // add unselecting class to all elements in the styleboard canvas except the ones to select
        $(".ui-selected", selectableContainer).not(elementsToSelect).removeClass("ui-selected").addClass("ui-unselecting");
        
        // add ui-selecting class to the elements to select
        $(elementsToSelect).not(".ui-selected").addClass("ui-selected");

        // trigger the mouse stop event (this will select all .ui-selecting elements, and deselect all .ui-unselecting elements)
        //selectableContainer.data("selectable")._mouseStop(null);
    }

    function unselectSelectableElement (selectableContainer) {
        //console.log("unselecting: ");
        $(".ui-selected", selectableContainer).removeClass("ui-selected").addClass("ui-unselecting");
    }

    function onMouseUp( event ) {
        // console.log("MOUSE UP");
        // console.log("sideViewActive: " + sideViewActive);

        //SELECT TERMS FROM SIDE NAVIGATION
        $( "#selectable" ).selectable({

            //if terms selected from side nav
            selected: function(event, ui) {
                //clear all splines from sideViewActive view
                
                if (sideViewActive) {
                    $("#selectable li").each(function(index) {
                        //console.log(index + ": " + $( this ).text());
                        var concept = $(this).text().toLowerCase();
                        var selected = termObj.getObjectByName(concept);

                        //set highlight of selected articles and draw splines to selected terms
                        for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                            var index = selected.userData.articleIndices[k];
                            articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                            articleObjects[index].userData.clicked = false;
                        }

                        var splineHolder = splineObj.getObjectByName(concept);
                        if (splineHolder != undefined) {
                            //remove splines that were previously created
                            for (var i = splineHolder.children.length - 1; i >= 0; i--) {
                                //console.log(splineHolder.children[i]);
                                splineObj.remove(splineHolder.children[i]);
                            }
                            scene.remove(splineObj);
                        }
                        unselectSelectableElement($("#selectable"), $("#selectable li") );
                    });
                }
                if(sideViewActive) sideViewActive = false;

                if ($(ui.selected).hasClass('click-selected')) {
                    //if clicking on previously selected term
                    $(ui.selected).removeClass('ui-selected click-selected');

                    //console.log('same topic clicked');
                    var lc = ui.selected.innerText.toLowerCase();
                    //console.log(lc);

                    //console.log("selectedArticles has: " + selectedArticles.length);
                    if (selectedArticles.length > 0) {
                        for (var n = 0; n < selectedArticles.length; n++) {
                            var articleArray = selectedArticles[n].tempArray;

                            for (var m = 0; m < articleArray.length; m++) {
                                var index = articleArray[m];
                                articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                                articleObjects[index].userData.clicked = false;
                            }

                            var splineHolder = splineObj.getObjectByName(selectedArticles[n].tempName);
                            if (splineHolder != undefined) {
                                //remove splines that were previously created
                                for (var i = splineHolder.children.length - 1; i >= 0; i--) {
                                    //console.log(splineHolder.children[i]);
                                    splineObj.remove(splineHolder.children[i]);
                                }
                                scene.remove(splineObj);
                            }
                        }
                    }

                    //clear selectedArticles array
                    //selectedArticles.length = 0;
                    for(var m = 0; m < selectedArticles.length; m++) {
                        if(selectedArticles[m].tempName == lc) {
                            selectedArticles.splice(m, 1);
                            break;
                        }
                    }
                    moveTermsDownNoSpline();
                    //console.log(selectedArticles);

                } else {
                    //if clicking on new term
                    //console.log("new topic clicked");

                    $(ui.selected).addClass('click-selected');
                    var lc = ui.selected.innerText.toLowerCase();
                    //console.log(lc);

                    var splineHolder = splineObj.getObjectByName(lc);
                    // console.log("splineHolder: ");
                    // console.log(splineHolder);

                    // console.log("termObj: ");
                    // console.log(termObj);

                    //console.log(scene.getObjectByName(lc));
                    var selected = termObj.getObjectByName(lc);
                    //console.log(selected);
                    //var termPos = selected.position;
                    //console.log("selected name: " + selected.name);

                    var tempSelectedObj = {};
                    tempSelectedObj.tempName = selected.name;
                    tempSelectedObj.tempArray = selected.userData.articleIndices.slice();
                    //console.log(tempSelectedObj);
                    selectedArticles.push(tempSelectedObj);
                    // console.log(selectedArticles);
                    // console.log(selectedArticles.length);

                    //scene.remove(splineObj.getObjectByName(tempName));
                    var splineHolder = splineObj.getObjectByName(selected.name);
                    // console.log("splineHolder: ");
                    // console.log(splineHolder);

                    //set highlight of selected articles and draw splines to selected terms
                    for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                        var index = selected.userData.articleIndices[k];
                        //console.log(articleObjects[index].userData.id);

                        //articleObjects[index].material.color.setHex( 0xFFFCC7); //0xFEFFA9); //0xFFF586); //0xFECA40); //0xF3CE00 );
                        articleObjects[index].material.uniforms.innerCol.value = new THREE.Color ( 0xFFFCC7 );
                        articleObjects[index].userData.clicked = true;

                        if (k % 2 === 0) {
                            drawSplines ( articleObjects[index], selected, lc );
                        }
                    }

                    splineObj.name = lc;
                    scene.add( splineObj );

                    moveTermsDownNoSpline();
                }
            },
            unselected: function( event, ui ) {
                $(ui.unselected).removeClass('click-selected');
                //console.log("unselected " + ui.unselected.innerText.toLowerCase());

                //if the array for what was selected on last click is populated, then change color of those articles back to original color

                //console.log("selectedArticles has: " + selectedArticles.length);
                if (selectedArticles.length > 0) {
                    for (var n = 0; n < selectedArticles.length; n++) {
                        var articleArray = selectedArticles[n].tempArray;
                        //console.log("selectedArticles name: " + selectedArticles[n].tempName);
                        for (var m = 0; m < articleArray.length; m++) {
                            var index = articleArray[m];
                            articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                            articleObjects[index].userData.clicked = false;
                        }

                        var splineHolder = splineObj.getObjectByName(selectedArticles[n].tempName);
                        if (splineHolder != undefined) {
                            //remove splines that were previously created
                            for (var i = splineHolder.children.length - 1; i >= 0; i--) {
                                //console.log(splineHolder.children[i]);
                                splineObj.remove(splineHolder.children[i]);
                            }
                            scene.remove(splineObj);
                        }
                    }
                }

                //clear selectedArticles array
                for(var m = 0; m < selectedArticles.length; m++) {
                    if(selectedArticles[m].tempName == ui.unselected.innerText.toLowerCase()) {
                        selectedArticles.splice(m, 1);
                        break;
                    }
                }
                //console.log(selectedArticles);
                moveTermsDownNoSpline();
            }

        });
    }

    function onMouseMove( event ) {
        //event.preventDefault();
        var mouseX = event.pageX;
        var mouseY = event.pageY;

        mouse.x = (event.clientX / renderer.domElement.width) * window.devicePixelRatio * 2 - 1;
        mouse.y = ((event.clientY / renderer.domElement.height) * window.devicePixelRatio * 2 - 1) * -1;

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( articleObjects );

        var intersectsTerms = raycaster.intersectObjects( termObjects );

        if ( intersects.length > 0 ) {

            if ( INTERSECTED != intersects[ 0 ].object ) {

                if ( INTERSECTED )  {

                    INTERSECTED.material.uniforms.innerCol.value = INTERSECTED.userData.colour;

                    //console.log(INTERSECTED.userData.clicked);

                } else {
                    INTERSECTED = intersects[ 0 ].object;
                    INTERSECTED.material.uniforms.innerCol.value = new THREE.Color( 0xccff00 );
                }
                //console.log(INTERSECTED.name);
                //console.log(INTERSECTED.userData);
                //console.log(INTERSECTED.position);

                $("#articleInfo").css({'top':mouseY,'left':mouseX })
                    .stop(true,true)
                    .fadeIn('fast');

                //update article info
                $("#title").text(INTERSECTED.userData.title);
                if (INTERSECTED.userData.numAuthors > 1 ) {
                    $("#authors").text("Authors: " + INTERSECTED.userData.authors);
                } else {
                    $("#authors").text("Author: " + INTERSECTED.userData.authors);
                }
                $("#citations").text("Citations: " + INTERSECTED.userData.cites);
                // var url = INTERSECTED.userData.id;
                // $("#articleUrl a").prop('href', url);
                // $("#articleUrl a").text(url);

            }

        } else {

            if ( INTERSECTED )  {

                if (INTERSECTED.userData.clicked) {
                    INTERSECTED.material.uniforms.innerCol.value = new THREE.Color( 0xFFFCC7 );
                } else {
                    INTERSECTED.material.uniforms.innerCol.value = INTERSECTED.userData.colour;
                }

                $("#articleInfo").stop(true,true).fadeOut('fast');
            }

            INTERSECTED = null;

        }

        if ( intersectsTerms.length > 0 ) {
            //console.log(intersectsTerms);
            if ( INTERSECTED_TERMS != intersectsTerms[ 0 ].object ) {

                if ( INTERSECTED_TERMS ) INTERSECTED_TERMS.material.color.setHex( INTERSECTED_TERMS.currentHex );

                INTERSECTED_TERMS = intersectsTerms[ 0 ].object;
                INTERSECTED_TERMS.currentHex = INTERSECTED_TERMS.material.color.getHex();
                INTERSECTED_TERMS.material.color.setHex( 0xff0000 );
                //console.log(INTERSECTED_TERMS.userData);

            }
        } else {
            if ( INTERSECTED_TERMS ) INTERSECTED_TERMS.material.color.setHex( INTERSECTED_TERMS.currentHex );

            INTERSECTED_TERMS = null;
        }
    }


    var maxrad = 0;

    function drawShaderCircle(fillColor, strokeColor, radius, strokeWeight, x, y, z, rotx, roty, rotz, scalar, id, title, authors, numAuthors, numCites) {

        //shader stuff

        maxrad = Math.max(maxrad, radius);

        var uniforms = {
            innerCol: {
                type: 'c', // a color
                value: fillColor
            },
            strokeCol: {
                type: 'c', // a color
                value: strokeColor
            },
            radius: {
                type: 'f', // a float
                value: radius
            },
            stroke: {
                type: 'f', //a float
                value: strokeWeight
            }
        };


        var shaderMaterial = new THREE.ShaderMaterial( {
            uniforms:       uniforms,
            vertexShader:   document.getElementById( 'circleVertexShader' ).textContent,
            fragmentShader: document.getElementById( 'circleFragmentShader' ).textContent,
            blending:       THREE.NormalBlending,
            depthTest:      true,
            transparent:    true,
            side:           THREE.DoubleSide,
            linewidth:      2
        });

        var square = new THREE.Shape();
        square.moveTo( 0, 0 );
        square.lineTo( 0, radius );
        square.lineTo( radius, radius );
        square.lineTo( radius, 0 );
        square.lineTo( 0, 0 );

        var extrudeSettings = { amount: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1, material: shaderMaterial }
        var squareGeom = new THREE.ShapeGeometry( square );
        var extrudeGeom = new THREE.ExtrudeGeometry( square, extrudeSettings );

        var squareMesh = new THREE.Mesh( squareGeom, shaderMaterial );

        squareMesh.position.set( x - radius/2, y, z - radius/2);
        squareMesh.rotation.set( rotx, roty, rotz );
        squareMesh.scale.set( scalar, scalar, scalar );

        squareMesh.userData = { id: id, title: title, authors: authors, colour: fillColor, clicked: false, cites: numCites, numAuthors: numAuthors, radius: radius };
        squareMesh.name = id;

        articleObj.add( squareMesh );
        articleObjects.push( squareMesh );
    }

    function drawTermDiamond( size, fillColor, x, y, z, term, articleIndices, ypos ) {
        var extrudeSettings = { amount: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 }

        var rect = new THREE.Shape();
        rect.moveTo(0, 0);
        rect.lineTo(0, size);
        rect.lineTo(size, size);
        rect.lineTo(size, 0);
        rect.lineTo (0, 0);

        var rectGeom = new THREE.ExtrudeGeometry( rect, extrudeSettings );
        var material = new THREE.MeshBasicMaterial( { color: fillColor, side: THREE.DoubleSide });

        var rectMesh = new THREE.Mesh( rectGeom, material );

        rectMesh.position.set(x, y, z);
        rectMesh.rotation.set( Math.PI/2, 0, Math.PI/4 );
        rectMesh.name = term;
        rectMesh.userData = { id: term, ypos: ypos, articleIndices: articleIndices };

        termObj.add( rectMesh );
        termObjects.push( rectMesh );

    }

    function makeCircleGeometryLinePieces(radius, segments) {
        var geometry = new THREE.Geometry();    
        var segmentStep = (1 / segments) * 2 * Math.PI;
        var theta = 0;

        for(var i = 0; i <= segments - 1; i++) {
            geometry.vertices.push(new THREE.Vector3( Math.cos( theta ) * radius, 0, Math.sin( theta ) * radius ) )
            theta += segmentStep;
            geometry.vertices.push(new THREE.Vector3( Math.cos( theta ) * radius, 0, Math.sin( theta ) * radius ) ); 
        }
        return geometry;
    }

    //variables for circlePoints / merged geometry
    var circleMatrix = new THREE.Matrix4();
    var circlePositionVector = new THREE.Vector3();
    var circleGeometry = makeCircleGeometryLinePieces(1, 24);

    function drawCirclePoints ( mergedGeom, radius, x, y, z) {
        circlePositionVector.set(x, y, z);
        circleMatrix.makeScale(radius, radius, radius);
        circleMatrix.setPosition(circlePositionVector);
        mergedGeom.merge(circleGeometry, circleMatrix);
    }

    function drawGrid() {
        var gridColor = new THREE.Color(0xd9f7ad);
        var blackColor = new THREE.Color(0x000000);
        var gridColorAlpha = gridColor.lerp(blackColor, 0.75);

        //var gridXZ_1 = new THREE.GridHelper(1500, 200);
        //gridXZ_1.setColors( gridColorAlpha, gridColorAlpha );
        //gridXZ_1.position.set(340, 0, 760);
        //gridXZ_1.position.set(0, 0, 0);
        //scene.add(gridXZ_1);

        var gridXZ_2 = new THREE.GridHelper(1500, 200);
        gridXZ_2.name = "lowerGrid";
        gridXZ_2.setColors( gridColorAlpha, gridColorAlpha );
        gridXZ_2.position.set(500, termOffset, 800);
        scene.add(gridXZ_2);
    }

    function loadArticles() {
        var request = $.ajax({
            type: "GET",
            url: "data/articlesNewInfo4.json",
            dataType: 'JSON',
            contentType: 'application/json'
        })
            .done(function(data) {
                //console.log( "success loading articles" );         
                //console.log(data);

                parseArticle(data);

                //console.log(articles.length);
            })
            .fail(function() {
                console.log( "error" );
            });
        //
    }

    function parseArticle(data) {
        for (d in data.articles) {
            var item = data.articles[d];

            tempArticle = {};
            tempArticle.id = item.id;
            tempArticle.x = item.x;
            tempArticle.y = item.y;
            tempArticle.z = item.z;
            tempArticle.radius = item.radius;
            tempArticle.title = item.title;
            tempArticle.published = item.published;
            tempArticle.authors = item.authors;
            tempArticle.numAuthors = item.numAuthors;
            tempArticle.numCites = item.numCites;
            tempArticle.numRefs = item.numRefs;

            articles.push(tempArticle);
        }

        //console.log("finished parsing articles - decide when to drawArticles");

        loadTerms(articles);
    }

    function drawArticles( array ) {
        var mergedGeomPub = new THREE.Geometry();
        var mergedGeomUnPub = new THREE.Geometry();

        for (var i = 0; i < array.length; i++) {

            var colorAuthorMin = new THREE.Color(0x3f348c);
            var colorAuthorMax2 = new THREE.Color(0xf47f31);
            var colorAuthorMax3 = new THREE.Color(0xd8301e);

            var mappedAuthor = map_range(array[i].numAuthors, 1, 5, 0, 1);
            var fillColor = colorAuthorMin.lerp(colorAuthorMax2, mappedAuthor);

            var authorStr;

            if (array[i].numAuthors > 5 ) {
                fillColor = colorAuthorMax2;

                for (var j = 0; j < 5; j++ ) {
                    authorStr += array[i].authors[j] + ", ";
                }

                authorStr += " ...";

            } else {
                authorStr = array[i].authors.join(", ");
            }

            if (array[i].numAuthors > 800) {
                fillColor = colorAuthorMax3;
            }

            var strokeColor;
            if (array[i].published) {
                strokeColor = new THREE.Color(0x00dbbb);
                drawCirclePoints ( mergedGeomPub, array[i].radius * .99, array[i].x, array[i].z, array[i].y);
            } else {
                strokeColor = new THREE.Color(0x5309aa);
            drawCirclePoints ( mergedGeomUnPub, array[i].radius * .99, array[i].x, array[i].z, array[i].y);
            }
            drawShaderCircle(fillColor, strokeColor, array[i].radius * 2, 2.0, array[i].x, array[i].z, array[i].y, Math.PI/2, 0, 0, 1, array[i].id, array[i].title, authorStr, array[i].numAuthors, array[i].numCites);

        }

        var totalCirclePub = new THREE.Line(mergedGeomPub, new THREE.LineBasicMaterial( { color : 0x00dbbb}), THREE.LinePieces);
        var totalCircleUnPub = new THREE.Line(mergedGeomUnPub, new THREE.LineBasicMaterial( { color : 0x5309aa }), THREE.LinePieces);
        
        scene.add( totalCirclePub );
        scene.add( totalCircleUnPub );
        //console.log("size of articleObjects array: " + articleObjects.length);
        drawGrid();
        
        $("#loader").fadeOut( function() {
            startIntro(); //TOUR STARTS AFTER EVERYTHING LOADS
        });
    }

    function loadTerms(articleArray) {
        var request = $.ajax({
            type: "GET",
            url: "data/termNewInfo2.json",
            dataType: 'JSON',
            contentType: 'application/json'
        })
        .done(function(data) {
            //console.log( "success loading terms" );         
            //console.log(data);

            parseTerm(data, articleArray);

        })
        .fail(function() {
            console.log( "error" );
        });
    }

    function parseTerm( data, articleArray ) {

        for (d in data.terms) {
            var item = data.terms[d];
            var articleIndexArray = [];
            tempTerm = {};
            tempTerm.term = item.term;
            tempTerm.x = item.x;
            tempTerm.y = item.y;
            tempTerm.z = item.z;
            tempTerm.articles = item.articles;
            tempTerm.connections = item.connections;


            for (var i = 0; i < item.articles.length; i++) {
                //console.log("term article: " + item.articles[i]);
                for (var j = 0; j < articleArray.length; j++) {
                    if(item.articles[i] === articleArray[j].id) {
                        //console.log("article id: " + articleArray[j].id);
                        articleIndexArray.push(j);
                        break;
                    }
                }

            }

            tempTerm.articleIndex = articleIndexArray;

            terms.push(tempTerm);

        }

        // console.log(terms);
        // console.log(terms.length);
        //console.log("finished parsing terms - decide when to drawTerms");
        drawArticles(articles);
        drawTerms(terms);
    }

    function moveTermsDownNoSpline() {
        var terms = scene.getObjectByName("terms");
        //console.log(terms);    
        for (var i = 0; i < terms.children.length; i++) {
            var t = terms.children[i];
            //console.log(t);
            var index = 0;
            new TWEEN.Tween( t.position )
                .to({ x: t.position.x, y: t.userData.ypos, z: t.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .start();
        }
        var labels = scene.getObjectByName("sprites");
        //console.log(labels);
        for (var j = 0; j < labels.children.length; j++) {
            var l = labels.children[j];
            //console.log(l);
            new TWEEN.Tween( l.position )
                .to({ x: l.position.x, y: l.userData.ypos, z: l.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .start();
        }

        var g = scene.getObjectByName("lowerGrid");
        new TWEEN.Tween (g.position)
            .to({ x: g.position.x, y: termPosLower, z: g.position.z}, 1000)
            .easing( TWEEN.Easing.Quadratic.InOut )
            .start();       
    }

    function moveTermsDown( ) {

        var terms = scene.getObjectByName("terms");
        //console.log(terms);    
        for (var i = 0; i < terms.children.length; i++) {
            var t = terms.children[i];
            //console.log(t);
            var index = 0;
            new TWEEN.Tween( t.position )
                .to({ x: t.position.x, y: t.userData.ypos, z: t.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .onComplete(function() {
                    //console.log(i);
                    index++;
                    //console.log(index);
                    //console.log("tourActive: " + tourActive);
                    if(index === terms.children.length && !tourActive) {
                        turnOnSplines();
                        //console.log("finished tweening terms");
                    } else if (index === terms.children.length && tourActive && !navViewActive) {
                        //console.log("only turn on physical cosmology");
                        turnOnSpline( "physical cosmology" );
                    }
                })
                .start();
        }
        var labels = scene.getObjectByName("sprites");
        //console.log(labels);
        for (var j = 0; j < labels.children.length; j++) {
            var l = labels.children[j];
            //console.log(l);
            new TWEEN.Tween( l.position )
                .to({ x: l.position.x, y: l.userData.ypos, z: l.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .start();
        }

        var g = scene.getObjectByName("lowerGrid");
        new TWEEN.Tween (g.position)
            .to({ x: g.position.x, y: termPosLower, z: g.position.z}, 1000)
            .easing( TWEEN.Easing.Quadratic.InOut )
            .start();        
    }

    function moveTermsToStartPos() {
        var terms = scene.getObjectByName("terms");
        //console.log(terms);    
        for (var i = 0; i < terms.children.length; i++) {
            var t = terms.children[i];
            //console.log(t);
            var index = 0;
            new TWEEN.Tween( t.position )
                .to({ x: t.position.x, y: termPosGridLevel + 50, z: t.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .onComplete(function() {
                    //console.log(i);
                    index++;
                    //console.log(index);
                    if(index === terms.children.length) {
                        turnOffSplines();
                        //console.log("finished tweening terms");
                    }
                })
                .start();
        }
        var labels = scene.getObjectByName("sprites");
        //console.log(labels);
        for (var j = 0; j < labels.children.length; j++) {
            var l = labels.children[j];
            //console.log(l);
            new TWEEN.Tween( l.position )
                .to({ x: l.position.x, y: termPosGridLevel, z: l.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .start();
        }

        var g = scene.getObjectByName("lowerGrid");
        new TWEEN.Tween (g.position)
            .to({ x: g.position.x, y: termPosGridLevel, z: g.position.z}, 1000)
            .easing( TWEEN.Easing.Quadratic.InOut )
            .start();        
    }


    function moveTermsUp() {
        var terms = scene.getObjectByName("terms");
        //console.log(terms);    
        for (var i = 0; i < terms.children.length; i++) {
            var t = terms.children[i];
            //console.log(t);
            var index = 0;
            new TWEEN.Tween( t.position )
                .to({ x: t.position.x, y: termPosAboveGrid + 50, z: t.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .onComplete(function() {
                    //console.log(i);
                    index++;
                    //console.log(index);
                    if(index === terms.children.length) {
                        turnOffSplines();
                        //console.log("finished tweening terms");
                    }
                })
                .start();
        }
        var labels = scene.getObjectByName("sprites");
        //console.log(labels);
        for (var j = 0; j < labels.children.length; j++) {
            var l = labels.children[j];
            //console.log(l);
            new TWEEN.Tween( l.position )
                .to({ x: l.position.x, y: termPosAboveGrid, z: l.position.z} , 1000)
                .easing( TWEEN.Easing.Quadratic.InOut )
                .start();
        }

        var g = scene.getObjectByName("lowerGrid");
        new TWEEN.Tween (g.position)
            .to({ x: g.position.x, y: termPosGridLevel, z: g.position.z}, 1000)
            .easing( TWEEN.Easing.Quadratic.InOut )
            .start();        
    }

    function drawTerms ( termArray, articleArray ) {
        for (var i = 0; i < termArray.length; i++) {
            var t1 = termArray[i];
            // console.log("t1: " );
            //console.log((t1.x + 300) + ", " + termOffset + 2 * t1.z + ", " + t1.y);

            var fillColor = new THREE.Color ( 0xea4f1c );

            drawTermDiamond (20, fillColor, t1.x + 300, termPosGridLevel, t1.y, t1.term, t1.articleIndex, termPosLower + 2*t1.z);

            //console.log("DRAW CIRCLE");
            //console.log(t1.term + " - x: " + t1.x + " z: " + t1.y  + " y: " + t1.z);
            //console.log(termObj);
            var title = toTitleCase(t1.term);

            var spritey = makeTextSprite(" " + title, termPosLower + 2*t1.z  - 50,
                   { fontsize: 100, 
                        fontface: "Georgia", 
                        //borderColor: {r:234, g:79, b:28, a:1.0}, 
                        borderColor: {r: 107, g: 107, b: 107, a:1.0},
                        backgroundColor: {r: 55, g:55, b:55, a:0.9} } );
            spritey.position.set(t1.x + 300, termPosGridLevel + 50, t1.y);
            spriteObj.add( spritey );

            //for network lines between terms (seem like there are too many being drawn, or not transparent enough)
            //this is currently disabled for legibility
            /*
            for (t in t1.connections) {
                var connect1 = t1.connections[t];
                var connect1Id = t1.connections[t].id;
                console.log("t1 id: " + connect1Id);

                for (var j = i + 1; j < terms.length; j++) {
                    var t2 = terms[j];
                    //console.log("t2: " + t2.connections.length);

                    for(n in t2.connections) {
                        var connect2 = t2.connections[n];
                        var connect2Id = t2.connections[n].id;
                        console.log("t2 id: " + connect2Id);
                    }
                    if (connect1Id === connect2Id) {
                        console.log("DRAW LINE");
                        //drawLine(t1.x * 0.1, t1.z * 0.1, t1.y * 0.1, t2.x * 0.1, t2.z * 0.1, t2.y * 0.1, 0xff0000);
                         //drawLine(t1.x, termOffset + 2 * t1.z, t1.y, t2.x, termOffset + 2 * t2.z, t2.y, 0xff0000);
                    }
                }
            }
             console.log("____________________");
            */
        }
        termObj.name = "terms";
        spriteObj.name = "sprites";
        //console.log(termObj);
    }

    function drawSplines( article, term, name ) {

        //shader stuff

        attributes = {
            customColor: {    type: 'c', value: [] },
            customOpacity: { type: 'f', value: []}
        };

        var shaderMaterial = new THREE.ShaderMaterial( {
            attributes:     attributes,
            vertexShader:   document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            blending:       THREE.NormalBlending,
            depthTest:      true,
            transparent:    true,
            side:           THREE.DoubleSide,
            linewidth:      2
        });

        var slideA = 0.8;
        var slideB = 1 - slideA;

        var start = new THREE.Vector3(article.position.x + article.userData.radius/2, article.position.y, article.position.z + article.userData.radius/2);
        var end = new THREE.Vector3(term.position.x, term.position.y, term.position.z);
        var startMid = new THREE.Vector3(slideA * start.x + slideB * end.x, slideA * start.y + slideB * end.y, start.z -.25 * Math.abs(end.z - start.z));
        var endMid = new THREE.Vector3(slideA * end.x + slideB * start.x, slideA * end.y + slideB * start.y, end.z + .35 * Math.abs(end.z - start.z));

        //Create a closed bent a sine-like wave
        var curve = new THREE.SplineCurve3( [
            // new THREE.Vector3(start.x, start.y - 20, start.z),
            start,
            startMid,
            endMid,
            end
            // new THREE.Vector3(end.x, end.y + 20, end.z)
        ] );

        var geometry = new THREE.Geometry();
        geometry.vertices = curve.getPoints( 30 );

        //shader stuff
        var values_color = attributes.customColor.value;
        for ( var v = 0; v < geometry.vertices.length; v++ ) {
            values_color[ v ] = new THREE.Color(THREE.ColorKeywords.white);
            values_color[ v ].set( 0xea4f1c );
            attributes.customOpacity.value[ v ] = 0.2;
        }

        //Create the final Object3d to add to the scene
        var splineObject = new THREE.Line( geometry, shaderMaterial );
 
        splineObj.add( splineObject );

        //scene.add( splineObject );
    }

    function drawLine(x1, y1, z1, x2, y2, z2, strokeColor) {

        //shader stuff

        attributes = {
            customColor: {    type: 'c', value: [] },
            customOpacity: { type: 'f', value: []}
        };

        var shaderMaterial = new THREE.ShaderMaterial( {
            attributes:     attributes,
            vertexShader:   document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            blending:       THREE.NormalBlending,
            depthTest:      true,
            transparent:    true,
            side:           THREE.DoubleSide,
            linewidth:      2
        });

        var geometry = new THREE.Geometry();
        geometry.vertices.push(
            new THREE.Vector3( x1, y1, z1 ),
            new THREE.Vector3( x2, y2, z2 )
        );

        //shader stuff
        var values_color = attributes.customColor.value;
        for ( var v = 0; v < geometry.vertices.length; v++ ) {
            values_color[ v ] = new THREE.Color(THREE.ColorKeywords.black);
            values_color[ v ].set( 0xea4f1c );
            attributes.customOpacity.value[ v ] = 0.25;
        }


        var line = new THREE.Line( geometry, shaderMaterial );
        scene.add( line );
    }

    function rect(ctx, x, y, w, h) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+w, y);
        ctx.lineTo(x+w, y+h);
        ctx.lineTo(x, y+h);
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    function makeTextSprite( message, ypos, parameters ) {
        var group = new THREE.Object3D();

        if ( parameters === undefined ) parameters = {};

        var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Georgia";
        var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
        var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
        var borderColor = parameters.hasOwnProperty("borderColor") ?parameters["borderColor"] : { r:255, g:255, b:255, a:1.0 };
        var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?parameters["backgroundColor"] : { r:0, g:0, b:0, a:1.0 };
        var textColor = parameters.hasOwnProperty("textColor") ?parameters["textColor"] : { r:255, g:255, b:255, a:1.0 };

        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = 2160;
        canvas.height = 200;
        var context = canvas.getContext('2d');
        context.font = "Bold " + fontsize + "px " + fontface;
        var metrics = context.measureText( message );
        //console.log(message);
        //console.log("metrics: " + metrics.width);
        var textWidth = metrics.width;

        context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

        context.lineWidth = borderThickness;

        rect(context, borderThickness/2 + (canvas.width/2) - (textWidth/2), borderThickness/2 , (textWidth * 1.025 + borderThickness), fontsize * 1.3 + borderThickness);

        context.fillStyle = "rgba("+textColor.r + ", " + textColor.g+", "+textColor.b+", 1.0)";
        context.fillText( message, borderThickness + (canvas.width/2) - (textWidth/2), (fontsize));

        //console.log('textWidth: ' + textWidth);

        var labelTexture = new THREE.Texture(canvas); //label texture
        labelTexture.generateMipmaps = false;
        labelTexture.needsUpdate = true;

        var texture = new THREE.Texture(context); //white texture
        texture.needsUpdate = true;

        var spriteMaterial = new THREE.SpriteMaterial( { map: texture });
        var sprite = new THREE.Sprite( spriteMaterial );
        sprite.scale.set(460, fontsize, fontsize);

        var spriteMaterial2 = new THREE.SpriteMaterial( { map: labelTexture });
        var labelsprite = new THREE.Sprite( spriteMaterial2);
        labelsprite.scale.set(fontsize * 10, fontsize * 0.9, fontsize * 0.75);

        group.userData = { width: textWidth, ypos: ypos };

        var strippedStr = message.substring(1); //take out space in front of message
        
        if ($.inArray(strippedStr, frequentKeywords) === -1) {
            group.userData.frequent = false;
        } else {
            group.userData.frequent = true;
        }
        
        group.name = message;

        //group.add(sprite);
        group.add(labelsprite);

        //return labelsprite;
        return group;
    }

    //UTIL FUNCTIONS
    function map_range(value, low1, high1, low2, high2) {
        return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    }

    function toTitleCase(str) {
        str = str.replace(/^\s+/, '');
        str = str.charAt(0).toUpperCase() + str.substr(1);
        return str;
    }

    function onWindowResize() {
        //console.log("resizing window");

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

</script>
</body>
</html>