<!DOCTYPE html>
<html>
<head>
    <title>Relativity&#39;s Reach</title>
    <link href="css/jquery-ui.v1.11.4.css" rel="stylesheet">
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="css/introjs.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
</head>
<body>
<div id="canvas-align">
    <div id="ThreeJS"></div>

    <div id="hud" class="visible">
        <div id = "loader"></div>
        <div id="header" alt="Relativity's Reach"></div>
        <div id="keyInfo" class="noselect">
            <div id="navButtons" class="noselect">
                <button id="topView" onclick="topView();">TOP VIEW</button>
                <button id="bottomView" onclick="bottomView();">BOTTOM VIEW</button>
                <button id="sideView" onclick="sideView();">SIDE VIEW</button>
                <button id="introTour" onclick="startIntro();">TOUR</button>
            </div>
            <div id="navInstructions" class="noselect">
                <h2>Navigation Info</h2>
                <div id="navInfo">
                    <br><span id="orbit">Orbit: left mouse / touch: one finger move</span>
                    <br><span id="zoom">Zoom: mousewheel / touch: two finger spread or squish</span>
                    <br><span id="pan">Pan: right mouse, or arrow keys / touch: two finger drag</span>
                </div>
            </div>
            <div id="authorKey" class="noselect">
                <h2>Key</h2>
                <br>
                <div>
                    <div id="circle_author1" class="circle"></div><span class="circle_info">&nbsp; 1 author</span>
                </div>
                <div>
                    <div id="circle_author2" class="circle"></div><span class="circle_info">&nbsp; 2 authors</span>
                </div>
                <div>
                    <div id="circle_author3" class="circle"></div><span class="circle_info">&nbsp; 3 authors</span>
                </div>
                <div>
                    <div id="circle_author4" class="circle"></div><span class="circle_info">&nbsp; 4 authors</span>
                </div>
                <div>
                    <div id="circle_author5" class="circle"></div><span class="circle_info">&nbsp; 5 - 849 authors</span>
                </div>
                <div>
                    <div id="circle_author6" class="circle"></div><span class="circle_info">&nbsp; 850+ authors</span>
                </div>
                <br>
                <div>
                    <div id="circle_pub" class="circle"></div><span class="circle_info">&nbsp; Currently published</span>
                </div>
                <div>
                    <div id="circle_unpub" class="circle"></div><span class="circle_info">&nbsp; Awaiting peer review</span>
                </div>
                <br>
                <div>
                    <div id="circle_noCites" class="circle"></div><span class="circle_info">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No citations</span>
                </div>
                <div>
                    <div id="circle_85cites" class="circle"></div><span class="circle_info">&nbsp; 85 citations</span>
                </div>
            </div>
        </div>
        <div id="UI">
            <div id="keyword-container" class="noselect">
                <h2 style="padding-left: 5px;">Concept Keywords</h2>
                <ol id="selectable">
                    <li class="ui-widget-content">Black hole</li>
                    <li class="ui-widget-content">Physical cosmology</li>
                    <li class="ui-widget-content">String theory</li>
                    <li class="ui-widget-content">Gravitation</li>
                    <li class="ui-widget-content">Dark matter</li>
                    <li class="ui-widget-content">Spacetime</li>
                    <li class="ui-widget-content">Special relativity</li>
                    <li class="ui-widget-content">Time</li>
                    <li class="ui-widget-content">Quantum gravity</li>
                    <li class="ui-widget-content">Gravitational wave</li>
                    <li class="ui-widget-content">Big bang</li>
                    <li class="ui-widget-content">Standard model</li>
                    <li class="ui-widget-content">Hawking radiation</li>
                    <li class="ui-widget-content">Dark energy</li>
                    <li class="ui-widget-content">Symmetry</li>
                </ol>
            </div>
        </div>

    </div>

    <div id="articleInfo" class="visible">
        <div><span id="title" ></span></div>
        <div><span id="authors" ></span></div>
        <div><span id="citations" ></span></div>
        <div><span id="articleUrl"><a href="" target="_blank"></a></span></div>
    </div>
</div>
<script type="text/javascript" src="js/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="js/jquery-ui.v1.11.4.min.js"></script>
<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/OrbitControls.js"></script>
<script type="text/javascript" src="js/tween.min.js"></script>
<script type="text/javascript" src="js/Detector.js"></script>
<script type="text/javascript" src="js/stats.min.js"></script>
<script type="text/javascript" src="js/intro.js"></script>
<script type="text/javascript" src="js/jquery.scrollto.min.js"></script>


<!-- 
<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/DotScreenShader.js"></script>
<script src="js/shaders/RGBShiftShader.js"></script>
<script src="js/shaders/FilmShader.js"></script> 
<script src="js/shaders/ConvolutionShader.js"></script>
<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/BloomPass.js"></script>
<script src="js/postprocessing/FilmPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
 -->


<script type="x-shader/x-vertex" id="vertexshader">
    //for spline object - have transparency
    attribute vec3 customColor;
    attribute float customOpacity;

    varying vec3 vColor;
    varying float vOpacity;

    void main() {
        vColor = customColor;
        vOpacity = customOpacity;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    //for spline object - have transparency
    //attribute vec3 customColor;
    varying vec3 vColor;
    varying float vOpacity;

    void main() {
        gl_FragColor = vec4( vColor, vOpacity);
    }
</script>

<script type="x-shader/x-vertex" id="circleVertexShader">
    // void main() {
    //     gl_Position = vec3(aVertexPos, 1.);
    // }    
    varying vec2 vUV;
    void main() {
        vUV = position.xy;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
</script>

<script type="x-shader/x-fragment" id="circleFragmentShader">
    uniform vec3 innerCol;
    uniform vec3 strokeCol;
    uniform float radius;
    uniform float stroke;

    varying vec2 vUV;


    void main() {
        // rad ~5
        // stroke 2...
        //float border = (radius - stroke/2.) / (stroke/2.+ radius);
        float dist = distance(vUV, vec2(radius / 2.0, radius / 2.0));
        float circleRadius = radius / 2.0;
        float borderRadius = circleRadius - stroke / 2.0;

        if (dist < circleRadius && dist > borderRadius) {
            gl_FragColor = vec4(strokeCol, 1.0);
        }
        else if (dist < circleRadius) {
            gl_FragColor = vec4(innerCol, 1.0);
        }
        else {
            discard;
        }

        //if(d <= border) gl_FragColor = vec4(innerCol, 1.);
        //else if(d > border && d < 1.) gl_FragColor = vec4(strokeCol, 1.);
        //else gl_FragColor = vec4(1);
    }
</script>

<script>
    var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    //var isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);

    if (!isChrome) {
        alert("For best viewing results, please load this visualization in Google Chrome or another WebGL enabled browser");
        // console.log("BROWSER NOT CHROME");
    }
    //standard global variables
    var container, scene, camera, renderer, controls, raycaster, mouse, composer, stats;
    var cameraOrtho, sceneOrtho;
    var mouse = { x: 0, y: 0 };
    var INTERSECTED, INTERSECTED_TERMS;
    var SCREEN_WIDTH, SCREEN_HEIGHT;

    //custom global variables
    var mesh;

    //data global variables
    var articles = [];
    var terms = [];

    var articleObjects = [];
    var termObjects = [];
    var termObj;
    var articleObj;
    var splineObj;
    var spriteObj;

    //shader variables
    var attributes;

    var selectedArticles = [];

    var tourActive = false;

    var termOffset = -1500;
    var labelDistThreshold = 3600;

    var eyeTargetScale;

    init();

    // postprocessing

    function startIntro(){
        var intro = introJs();

        intro.setOptions({
            steps: [
                {

                    intro: "<h2>Relativity's Reach</h2><br>This interactive graphic visualizes the impact of the general theory of relativity on current physics research a hundred years after Albert Einstein first described how gravity emerges from the bending of space and time.<br><br>Data on the modern research trends comes from arXiv.org, an online database of scientific papers."
                },
                {
                    //element: '#step2',
                    intro: "<h2>Data Source</h2><br>Each colored dot represents a paper uploaded in 2014 to the well-known online database arXiv.org. Each paper has been classified as having 'General Relativity - Quantum Cosmology' as its main category - a total of 2,435 papers.<br><br>Use your mouse to roll over an article and reveal its title, authors, number of citations and URL on arXiv.org. Right (or CTRL) clicking on the article dot when highlighted opens a new window to the article's page on arXiv.org."
                },
                {
                    //element: '#keyword-container',
                    intro: "<h2>Concept Keywords</h2><br>A powerful text analysis tool, which is now part of IBM's Watson AI system, examined the abstracts of all 2,435 papers in the General Relativity - Quantum Cosmology category and identified keywords for critical concepts within those papers. These keywords were edited for relevancy by <i>Scientific American</i> down to 61. The 15 most used keywords are visible here in order of frequency.<br><br>You may select a keyword to see which articles reference it. Select multiple keywords by dragging over multiple buttons or selecting while pressing the CTRL key.",
                    //position: 'right'
                },
                {
                    intro: "<h2>Article and Keyword Layout</h2><br>Article dots are positioned near keywords (diamonds). If the article has multiple keywords, the dot is placed between terms, such as the article with special relativity and Noether's theorem.<br><br> NOTE: This section and keywords in general need some thought / layout decisions."
                },
                {
                    intro: "<h2>Citations</h2><br>The size of the dot is based on how often the 2014 article has been cited since publication through the middle of this year. The smallest dot corresponds to a paper with no citations, whereas the largest dot has 85 citations."
                },
                {
                    intro: "<h2>Publication Status</h2><br>The colored circle around each dot indicates publication status. Many physicists put their papers on arXiv before they are published.<br><br>Articles with a bright blue outline have been published, while articles circled in dark purple are awaiting peer review."
                },
                {
                    intro: "<h2>Authors</h2><br>The number of authors per article generally varies between one and five. In some cases, like the LIGO research, there are over 850 authors for a single article."
                },
                {
                    //element:'#authorKey',
                    intro: "<h2>Key</h2><br>The color of the dot indicates number of authors.<br>The color of the dot's outline indicates the publication status.<br>The size of the dot indicates the number of citations.",
                    //position: 'left'
                },
                {
                    //element: '#navInstructions',
                    intro: "<h2>Navigation</h2><br>You may explore the visualization by using your mouse to orbit around the scene.<br><br>Orbit: left mouse / touch: one finger move<br>Zoom: mousewheel / touch: two finger spread or squish<br>Pan: right mouse, or arrow keys / touch: two finger drag<br><br>You can also select various views to focus on the top, bottom, or sides of the graphic. Select the tour to replay this introduction.",
                    //position: 'left'
                },
                {
                    //element: '#navButtons',
                    intro: "<h2>Views</h2><br>You can select various views to focus on the top, bottom, or sides of the graphic. Select the tour to replay this introduction.",
                    //position: 'left'
                }
            ],
            skipLabel: 'Exit',
            tooltipPosition: 'bottom',
            exitOnOverlayClick: true,
            showStepNumbers: false,
            overlayOpacity: 0.1
        });

        intro.onchange(function(targetElement, currentStep) {
            //console.log("Current Scene: " + intro._currentStep);
            var introTweenOptions = {duration: 1000, easing: TWEEN.Easing.Quadratic.InOut};

            
            switch(intro._currentStep) { 
                case 0: //INTRO SCREEN
                    tourActive = true;
                    moveAndLookAt(camera, new THREE.Vector3(580, 1390, 1600), new THREE.Vector3(435, -430, 560), introTweenOptions);
                    break;

                case 1: //Data Source - explains article rollover behavior
                    unselectSelectableElement($("#selectable"));
                    moveAndLookAt(camera, new THREE.Vector3(1350, 500, 1200), new THREE.Vector3(925, -1170, 75), introTweenOptions);
                    if( splineObj.children.length > 0 ) {
                        for ( s in splineObj.children) {
                            splineObj.remove(s);
                        }
                        scene.remove(splineObj);
                        var key = "physical cosmology";
                        var selected = termObj.getObjectByName(key);
                        for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                            var index = selected.userData.articleIndices[k];
                            //console.log(articleObjects[index].userData.id);
                            articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                            articleObjects[index].userData.clicked = false;
                        }
                    }
                    break;

                case 2: //Concept Keywords - shows how to highlight articles
                    moveAndLookAt(camera, new THREE.Vector3(130, 550, 2670), new THREE.Vector3(530, -570, 165), introTweenOptions);
                    //highlight physical cosmology
                    var key = "physical cosmology";
                    var selected = termObj.getObjectByName(key);

                    //set highlight of selected articles and draw splines to selected terms
                    for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                        var index = selected.userData.articleIndices[k];
                        //console.log(articleObjects[index].userData.id);
                        //articleObjects[index].material.color.setHex( 0xFFFCC7); //0xFEFFA9); //0xFFF586); //0xFECA40); //0xF3CE00 );
                        articleObjects[index].material.uniforms.innerCol.value = new THREE.Color ( 0xFFFCC7 );
                        articleObjects[index].userData.clicked = true;

                        if (k % 2 === 0) {
                            drawSplines ( articleObjects[index].position, selected.position, key );
                        }
                    }

                    splineObj.name = key;
                    scene.add( splineObj );
                    selectSelectableElement($("#selectable"), $("#selectable li:eq(1)"));
                    break;

                case 3: //Article and Keyword Layout
                    unselectSelectableElement($("#selectable"));

                    var str = "http://arxiv.org/abs/1401.4548v2";
                    var objlookAt = articleObj.getObjectByName(str);
                    //console.log(objlookAt);
                    moveAndLookAt(camera, new THREE.Vector3(objlookAt.position.x, objlookAt.position.y + 2000, objlookAt.position.z + 1e-10), objlookAt.position, introTweenOptions);

                    if(splineObj.children.length > 0) {
                        //console.log(splineObj.children.length);
                        for ( var i = 0; i < splineObj.children.length; i++) {
                            var child = splineObj.children[i];
                            //console.log(child);
                            splineObj.remove(child);
                        }
                        scene.remove(splineObj);
                        var key = "physical cosmology";
                        var selected = termObj.getObjectByName(key);
                        for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                            var index = selected.userData.articleIndices[k];
                            //console.log(articleObjects[index].userData.id);
                            articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                            articleObjects[index].userData.clicked = false;
                        }
                    }
                    break;

                case 4: //Citations
                    moveAndLookAt(camera, new THREE.Vector3(740, 300, 1111), new THREE.Vector3(485, -575, -190), introTweenOptions);
                    break;

                case 5: //Publication status
                    moveAndLookAt(camera, new THREE.Vector3(1146, 205, 633), new THREE.Vector3(600, -663, -143), introTweenOptions);
                    break;

                case 6: //Authors
                    moveAndLookAt(camera, new THREE.Vector3(1157, 580, 785), new THREE.Vector3(382, -1437, 867), introTweenOptions);
                    break;

                case 7: //Key (wide view)
                    topView();
                    break;

                case 8: //Navigation
                    var str = "http://arxiv.org/abs/1403.5306v2";
                    var objlookAt = articleObj.getObjectByName(str);
                    //console.log(objlookAt);
                    moveAndLookAt(camera, new THREE.Vector3(objlookAt.position.x + 700, objlookAt.position.y, objlookAt.position.z + 700), objlookAt.position, introTweenOptions);
                    break;

                case 9: //Views (bottomView)
                    bottomView();
                    break;
            }
        });

        intro.onexit(function() {
            //console.log("Intro completed");
            tourActive = false;
            topView();
        });

        intro.oncomplete(function() {
            //console.log("Intro completed");
            tourActive = false;
            topView();
        });

        intro.start();
    }

    window.mobileAndTabletcheck = function() {
      var check = false;
      (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
      return check;
    }




    function init() {
        //SCENE
        scene = new THREE.Scene();
        sceneOrtho = new THREE.Scene();

        termObj = new THREE.Object3D();
        splineObj = new THREE.Object3D();
        articleObj = new THREE.Object3D();
        spriteObj = new THREE.Object3D();

        scene.add( termObj );
        scene.add( splineObj );
        scene.add( articleObj );
        scene.add( spriteObj );

        //CAMERA
        //SCREEN_WIDTH = window.innerWidth;
        //SCREEN_HEIGHT = window.innerHeight;
        SCREEN_WIDTH = 960;
        SCREEN_HEIGHT = 680;
        var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 10, FAR = 10000;

        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set (-1345, 1250, 2865);
        camera.lookAt(250, -680, 930);
        scene.add(camera);

        //RENDERER
        if (Detector.webgl) {
            renderer = new THREE.WebGLRenderer( {antialias: true} );
        } else {
            console.log("using canvas renderer... slow");
            renderer = new THREE.CanvasRenderer();
        }
        
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        //renderer.shadowMapType = THREE.PCFSoftShadowMap;

        container = document.getElementById( 'ThreeJS' );
        document.body.appendChild(container);
        container.appendChild( renderer.domElement );

        //EVENTS
        controls = new THREE.OrbitControls( camera,  renderer.domElement );
        controls.maxDistance = 7000;
        controls.target.set( 250, -680, 930 );

        var startdir = new THREE.Vector3();
        startdir.subVectors( camera.position, controls.target );
        eyeTargetScale = Math.tan(camera.fov * (Math.PI/180) / 2) * startdir.length();

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        //LIGHT
        var light = new THREE.PointLight( 0xFFFFFF );
        // light.shadowMapWidth = 1024; // default is 512
        // light.shadowMapHeight = 1024; // default is 512
        light.position.set(100, 250, 100);

        var bottomLight = new THREE.PointLight( 0xFFFFFF );
        light.position.set(100, -2000, 100);

        scene.add(bottomLight);
        scene.add(light);

        //LOADING DATA
        loadArticles();

        //SHADERS
        /*
        var renderModel = new THREE.RenderPass( scene, camera );
        //var effectBloom = new THREE.BloomPass( .25 );
        var effectFilm = new THREE.FilmPass( 0,0,0, false );
        effectFilm.renderToScreen = true;


        composer = new THREE.EffectComposer( renderer );
        composer.addPass( renderModel );
        //composer.addPass( effectBloom );
        composer.addPass( effectFilm );


        composer.addPass( new THREE.RenderPass( scene, camera ) );
        composer.addPass( new THREE.BloomPass( 1.25 ));

        renderer.autoClear = false;
        */

           

        // SKYBOX
        // var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
        // var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
        // var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
        // scene.add(skyBox);


        ////////////
        // CUSTOM //
        ////////////
        var isMobile = {
            Android: function() {
                return navigator.userAgent.match(/Android/i);
            },
            BlackBerry: function() {
                return navigator.userAgent.match(/BlackBerry/i);
            },
            iOS: function() {
                return navigator.userAgent.match(/iPhone|iPad|iPod/i);
            },
            Opera: function() {
                return navigator.userAgent.match(/Opera Mini/i);
            },
            Windows: function() {
                return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
            },
            any: function() {
                return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
            }
        };

        if( isMobile.any() ) {
            console.log('Mobile');
            $("#navInstructions").css({ 'width': '165px'});
            $("#orbit").text("Orbit:  one finger move");
            $("#zoom").text("Zoom:  two finger spread or squish");
            $("#pan").text("Pan:  two finger drag");
        } else {
            $("#navInstructions").css({ 'width': '150px'});
            $("#orbit").text("Orbit: left mouse");
            $("#zoom").text("Zoom:  mousewheel");
            $("#pan").text("Pan:  right mouse, or arrow keys");
        }
            

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.bottom = '0px';
        stats.domElement.style.left = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseup', onMouseUp, false);
        window.addEventListener('mousedown', onMouseDown, false);
        window.addEventListener( 'resize', onWindowResize, false );

        $(window).keypress(function(e) {
            if (e.keyCode === 0 || e.keyCode === 32) {
                console.log('Space pressed');
                saveCamera();
            }
        });

        // kick off the renderer
        render();
    }

    function saveCamera() {
        console.log("Saving Camera");
        console.log(camera.position);
        console.log(camera.rotation);
        console.log(camera.quaternion);
        console.log(controls.center);
        console.log("articles");
        console.log(articleObjects[0].rotation);
        console.log(articleObjects[0].quaternion);

        var grid = scene.getObjectByName("lowerGrid");
        console.log(grid.position);
    }

    function bottomView() {
        console.log("bottomView");

        var grid = scene.getObjectByName("lowerGrid");
        moveAndLookAt(camera, new THREE.Vector3( grid.position.x - 225, grid.position.y - 3000, grid.position.z + 200 + 1e-10), new THREE.Vector3(grid.position.x - 225, grid.position.y, grid.position.z + 200), {
            duration: 1000,
            easing: TWEEN.Easing.Quadratic.InOut
        });
    }

    function topView() {
        console.log("topView");

        // TODO zoom out to fit...
        var grid = scene.getObjectByName("lowerGrid");
        moveAndLookAt(camera, new THREE.Vector3( grid.position.x - 80, grid.position.y + 4000, grid.position.z + 45 + 1e-10), new THREE.Vector3(grid.position.x - 80, grid.position.y, grid.position.z + 45), {
            duration: 1000,
            easing: TWEEN.Easing.Quadratic.InOut
        });
    }

    function sideView() {
        console.log("sideView");

        moveAndLookAt(camera, new THREE.Vector3( 400, -320, 4100), new THREE.Vector3(350, -860, 920), {
                    duration: 1000,
                    easing: TWEEN.Easing.Quadratic.InOut
                });
    }

    // Camera Tweening
    // Better just to save and pass quaternion?
    // This seems like the definitive issue thread on the top-axis flip issue
    // https://github.com/mrdoob/three.js/issues/1460
    function moveAndLookAt(camera, dstpos, dstlookat, options) {
        options || (options = {duration: 300, easing: TWEEN.Easing.Linear.None});

        var origpos = new THREE.Vector3().copy(camera.position); // original position
        var origrot = new THREE.Euler().copy(camera.rotation); // original rotation
        //console.log("origrot: " + origrot);

        camera.position.set(dstpos.x, dstpos.y, dstpos.z);
        camera.lookAt(dstlookat);
        var dstrot = new THREE.Euler().copy(camera.rotation);

        // Restore original position and rotation
        camera.position.set(origpos.x, origpos.y, origpos.z);
        camera.rotation.set(origrot.x, origrot.y, origrot.z);

        // Tween Camera
        // rotation (using slerp)
        (function () {
            var origQuat = new THREE.Quaternion().copy(camera.quaternion);
            var destQuat = new THREE.Quaternion().setFromEuler(dstrot);
            var lerpQuat = new THREE.Quaternion();
            var lerpPos = new THREE.Vector3();

            var o = {t: 0};
            new TWEEN.Tween(o).to({t: 1}, options.duration).easing(options.easing).onUpdate(function () {
                // Position
                lerpPos.lerpVectors(origpos, dstpos, o.t);
                camera.position.copy(lerpPos);

                // Rotation
                THREE.Quaternion.slerp(origQuat, destQuat, lerpQuat, o.t);
                camera.quaternion.copy(lerpQuat);
            }).onComplete(function () {
                // Update camera target
                controls.target.copy(dstlookat);
                controls.update();
            }).start();
        }).call(this);
    }

    // 60 hz
    function render() {
        stats.begin();
        TWEEN.update();

        /*
        if (articleObjects.length > 0) {
            for (var i = 0; i < articleObjects.length; i++) {
                var testPoint = articleObjects[i];
                
                //billboards articles towards camera (look like spheres)
                //testPoint.setRotationFromQuaternion( camera.quaternion );
                
                testPoint.matrixWorldNeedsUpdate = true;
                camera.matrixWorldNeedsUpdate = true;

                //trying to figure out how to angle specific ones, don't need to anymore...
                if (testPoint.matrixWorld) {

                    var finalMatrix = new THREE.Matrix4();
                    camera.matrixWorld;
                    finalMatrix.multiplyMatrices(camera.projectionMatrix, testPoint.matrixWorld);
                    //console.log(finalMatrix);
                }
            }
        }
        */
        //if we've drawn the grid
        if (scene.getObjectByName("lowerGrid")) {
            var grid = scene.getObjectByName("lowerGrid");

            var dist;
            dist = camera.position.distanceTo( grid.position );

            //sprite labels should only appear when close enough to read
            if (spriteObj != undefined && spriteObj.children.length > 60) {
                var spr = scene.getObjectByName("sprites");
                if (dist > labelDistThreshold) {
                    //turn off labels
                    //console.log(spr);
                    spr.visible = false;
                } else {
                    spr.visible = true;
                }
            }
        }
        
        //composer.render();
        renderer.render( scene, camera );
        stats.end();
        requestAnimationFrame(render);

    }

    function onMouseDown( event ) {
        //console.log("MOUSE DOWN");
        //console.log("tourActive is: " + tourActive);

        mouse.x = (event.clientX / renderer.domElement.width) * window.devicePixelRatio * 2 - 1;
        mouse.y = ((event.clientY / renderer.domElement.height) * window.devicePixelRatio * 2 - 1) * -1;

        raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects( articleObjects );

        if (intersects.length > 0) {
            //don't open article new window if clicking on UI elements
            if($('#selectable').is(':hover') || $('#navButtons').is(':hover') || $('#navInstructions').is(':hover') || $('#authorKey').is(':hover') || $('#header').is(':hover') || $('.introjs-tooltip:first').is(':hover')) {
                //console.log("over the term menu");
            } else {
                //opens new tab with article page
                if(event.which === 3) { //only opens on right click
                    window.open(intersects[0].object.userData.id);
                }
            }

            //disabled camera movement to point on click - but could be a good interface?
            //moveAndLookAt(camera, new THREE.Vector3(intersects[0].object.position.x, intersects[0].object.position.y + 50, intersects[0].object.position.z + 100), intersects[0].object.position, {duration: 1000});
        }
    }

    function selectSelectableElement (selectableContainer, elementsToSelect) {
        // console.log("selecting: ");
        // console.log(elementsToSelect);
        // add unselecting class to all elements in the styleboard canvas except the ones to select
        $(".ui-selected", selectableContainer).not(elementsToSelect).removeClass("ui-selected").addClass("ui-unselecting");
        
        // add ui-selecting class to the elements to select
        $(elementsToSelect).not(".ui-selected").addClass("ui-selected");

        // trigger the mouse stop event (this will select all .ui-selecting elements, and deselect all .ui-unselecting elements)
        //selectableContainer.data("selectable")._mouseStop(null);
    }

    function unselectSelectableElement (selectableContainer) {
        //console.log("unselecting: ");
        $(".ui-selected", selectableContainer).removeClass("ui-selected").addClass("ui-unselecting");
    }

    function onMouseUp( event ) {
        //console.log("MOUSE UP");

        //SELECT TERMS FROM SIDE NAVIGATION
        $( "#selectable" ).selectable({
            selected: function(event, ui) {

                if ($(ui.selected).hasClass('click-selected')) {
                    //if clicking on previously selected term
                    $(ui.selected).removeClass('ui-selected click-selected');

                    //console.log('same topic clicked');
                    var lc = ui.selected.innerText.toLowerCase();
                    //console.log(lc);

                    //console.log("selectedArticles has: " + selectedArticles.length);
                    if (selectedArticles.length > 0) {
                        for (var n = 0; n < selectedArticles.length; n++) {
                            var articleArray = selectedArticles[n].tempArray;

                            for (var m = 0; m < articleArray.length; m++) {
                                // var index = articleArray[m];
                                // articleObjects[index].material.color.setRGB(
                                // articleObjects[index].userData.colour.r,
                                // articleObjects[index].userData.colour.g,
                                // articleObjects[index].userData.colour.b );

                                var index = articleArray[m];
                                articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                                articleObjects[index].userData.clicked = false;
                            }

                            var splineHolder = splineObj.getObjectByName(selectedArticles[n].tempName);
                            if (splineHolder != undefined) {
                                //remove splines that were previously created
                                for (var i = splineHolder.children.length - 1; i >= 0; i--) {
                                    //console.log(splineHolder.children[i]);
                                    splineObj.remove(splineHolder.children[i]);
                                }
                                scene.remove(splineObj);
                            }
                        }
                    }

                    //clear selectedArticles array
                    //selectedArticles.length = 0;
                    for(var m = 0; m < selectedArticles.length; m++) {
                        if(selectedArticles[m].tempName == lc) {
                            selectedArticles.splice(m, 1);
                            break;
                        }
                    }

                    //console.log(selectedArticles);

                } else {
                    //if clicking on new term
                    //console.log("new topic clicked");

                    $(ui.selected).addClass('click-selected');
                    var lc = ui.selected.innerText.toLowerCase();
                    //console.log(lc);

                    var splineHolder = splineObj.getObjectByName(lc);
                    // console.log("splineHolder: ");
                    // console.log(splineHolder);

                    // console.log("termObj: ");
                    // console.log(termObj);

                    //console.log(scene.getObjectByName(lc));
                    var selected = termObj.getObjectByName(lc);
                    //console.log(selected);
                    //var termPos = selected.position;
                    //console.log("selected name: " + selected.name);

                    var tempSelectedObj = {};
                    tempSelectedObj.tempName = selected.name;
                    tempSelectedObj.tempArray = selected.userData.articleIndices.slice();
                    //console.log(tempSelectedObj);
                    selectedArticles.push(tempSelectedObj);
                    // console.log(selectedArticles);
                    // console.log(selectedArticles.length);

                    //scene.remove(splineObj.getObjectByName(tempName));
                    var splineHolder = splineObj.getObjectByName(selected.name);
                    // console.log("splineHolder: ");
                    // console.log(splineHolder);

                    //set highlight of selected articles and draw splines to selected terms
                    for (var k = 0; k < selected.userData.articleIndices.length; k++) {
                        var index = selected.userData.articleIndices[k];
                        //console.log(articleObjects[index].userData.id);

                        //articleObjects[index].material.color.setHex( 0xFFFCC7); //0xFEFFA9); //0xFFF586); //0xFECA40); //0xF3CE00 );
                        articleObjects[index].material.uniforms.innerCol.value = new THREE.Color ( 0xFFFCC7 );
                        articleObjects[index].userData.clicked = true;

                        if (k % 2 === 0) {
                            drawSplines ( articleObjects[index].position, selected.position, lc );
                        }



                        //articleObjects[index].geometry.colorsNeedUpdate = true;

                        // var newMat = articleObjects[index].material.clone();
                        // newMat.color.setHex( 0xffffff );
                        // console.log(newMat);

                        //dealing with children if there are some
                        // for (var j = 0; j < articleObjects[index].children; j++) {
                        //     //console.log(articleObjects[index].children[j]);
                        //     articleObjects[index].children[j].material.color.setHex( 0xffffff );
                        // }

                    }

                    splineObj.name = lc;
                    scene.add( splineObj );
                }
            },
            unselected: function( event, ui ) {
                $(ui.unselected).removeClass('click-selected');
                //console.log("unselected " + ui.unselected.innerText.toLowerCase());

                //if the array for what was selected on last click is populated, then change color of those articles back to original color

                //console.log("selectedArticles has: " + selectedArticles.length);
                if (selectedArticles.length > 0) {
                    for (var n = 0; n < selectedArticles.length; n++) {
                        var articleArray = selectedArticles[n].tempArray;
                        //console.log("selectedArticles name: " + selectedArticles[n].tempName);
                        for (var m = 0; m < articleArray.length; m++) {
                            // var index = articleArray[m];
                            // articleObjects[index].material.color.setRGB(
                            // articleObjects[index].userData.colour.r,
                            // articleObjects[index].userData.colour.g,
                            // articleObjects[index].userData.colour.b );

                            var index = articleArray[m];
                            articleObjects[index].material.uniforms.innerCol.value = articleObjects[index].userData.colour;
                            articleObjects[index].userData.clicked = false;
                        }

                        // articleObjects[index].material.uniforms.innerCol.value = new THREE.Color( 0xccff00 );
                        // articleObjects[index].userData.clicked = true;

                        var splineHolder = splineObj.getObjectByName(selectedArticles[n].tempName);
                        if (splineHolder != undefined) {
                            //remove splines that were previously created
                            for (var i = splineHolder.children.length - 1; i >= 0; i--) {
                                //console.log(splineHolder.children[i]);
                                splineObj.remove(splineHolder.children[i]);
                            }
                            scene.remove(splineObj);
                        }
                    }
                }

                //clear selectedArticles array
                for(var m = 0; m < selectedArticles.length; m++) {
                    if(selectedArticles[m].tempName == ui.unselected.innerText.toLowerCase()) {
                        selectedArticles.splice(m, 1);
                        break;
                    }
                }
                //console.log(selectedArticles);

            }

        });
    }

    function onMouseMove( event ) {
        //event.preventDefault();
        var mouseX = event.pageX;
        var mouseY = event.pageY;

        mouse.x = (event.clientX / renderer.domElement.width) * window.devicePixelRatio * 2 - 1;
        mouse.y = ((event.clientY / renderer.domElement.height) * window.devicePixelRatio * 2 - 1) * -1;

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( articleObjects );

        var intersectsTerms = raycaster.intersectObjects( termObjects );

        if ( intersects.length > 0 ) {

            if ( INTERSECTED != intersects[ 0 ].object ) {

                if ( INTERSECTED )  {

                    //INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                    INTERSECTED.material.uniforms.innerCol.value = INTERSECTED.userData.colour;

                    //console.log(INTERSECTED.userData.clicked);

                } else {
                    INTERSECTED = intersects[ 0 ].object;
                    INTERSECTED.material.uniforms.innerCol.value = new THREE.Color( 0xccff00 );
                }


                //INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                //INTERSECTED.material.color.setHex( 0xccff00 );
                //console.log(INTERSECTED.name);
                // console.log(INTERSECTED.userData);
                // console.log(INTERSECTED.position);

                $("#articleInfo").css({'top':mouseY,'left':mouseX })
                    .stop(true,true)
                    .fadeIn('fast');

                //update article info
                $("#title").text(INTERSECTED.userData.title);
                if (INTERSECTED.userData.numAuthors > 1 ) {
                    $("#authors").text("Authors: " + INTERSECTED.userData.authors);
                } else {
                    $("#authors").text("Author: " + INTERSECTED.userData.authors);
                }
                $("#citations").text("Citations: " + INTERSECTED.userData.cites);
                // var url = INTERSECTED.userData.id;
                // $("#articleUrl a").prop('href', url);
                // $("#articleUrl a").text(url);

            }

        } else {

            if ( INTERSECTED )  {

                if (INTERSECTED.userData.clicked) {
                    INTERSECTED.material.uniforms.innerCol.value = new THREE.Color( 0xFFFCC7 );
                } else {
                    //INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                    INTERSECTED.material.uniforms.innerCol.value = INTERSECTED.userData.colour;
                }

                $("#articleInfo").stop(true,true).fadeOut('fast');
            }

            INTERSECTED = null;

        }

        if ( intersectsTerms.length > 0 ) {
            //console.log(intersectsTerms);
            if ( INTERSECTED_TERMS != intersectsTerms[ 0 ].object ) {

                if ( INTERSECTED_TERMS ) INTERSECTED_TERMS.material.color.setHex( INTERSECTED_TERMS.currentHex );

                INTERSECTED_TERMS = intersectsTerms[ 0 ].object;
                INTERSECTED_TERMS.currentHex = INTERSECTED_TERMS.material.color.getHex();
                INTERSECTED_TERMS.material.color.setHex( 0xff0000 );
                //console.log(INTERSECTED_TERMS.userData);

            }
        } else {
            if ( INTERSECTED_TERMS ) INTERSECTED_TERMS.material.color.setHex( INTERSECTED_TERMS.currentHex );

            INTERSECTED_TERMS = null;
        }
    }


    var maxrad = 0;

    function drawShaderCircle(fillColor, strokeColor, radius, strokeWeight, x, y, z, rotx, roty, rotz, scalar, id, title, authors, numAuthors, numCites) {

        //shader stuff

        maxrad = Math.max(maxrad, radius);

        var uniforms = {
            innerCol: {
                type: 'c', // a color
                value: fillColor
            },
            strokeCol: {
                type: 'c', // a color
                value: strokeColor
            },
            radius: {
                type: 'f', // a float
                value: radius
            },
            stroke: {
                type: 'f', //a float
                value: strokeWeight
            }
        };


        var shaderMaterial = new THREE.ShaderMaterial( {
            uniforms:       uniforms,
            vertexShader:   document.getElementById( 'circleVertexShader' ).textContent,
            fragmentShader: document.getElementById( 'circleFragmentShader' ).textContent,
            blending:       THREE.NormalBlending,
            depthTest:      true,
            transparent:    true,
            side:           THREE.DoubleSide,
            linewidth:      2
        });

        var square = new THREE.Shape();
        square.moveTo( 0, 0 );
        square.lineTo( 0, radius );
        square.lineTo( radius, radius );
        square.lineTo( radius, 0 );
        square.lineTo( 0, 0 );

        // square.moveTo( -1 * radius, -1 * radius );
        // square.lineTo( -1 * radius, 0 );
        // square.lineTo( 0, 0 );
        // square.lineTo( 0, -1 * radius );
        // square.lineTo( -1 * radius, -1 * radius );


        var extrudeSettings = { amount: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1, material: shaderMaterial }
        var squareGeom = new THREE.ShapeGeometry( square );
        var extrudeGeom = new THREE.ExtrudeGeometry( square, extrudeSettings );

        //shader stuff
        // var values_color = attributes.customColor.value;
        // for ( var v = 0; v < squareGeom.vertices.length; v++ ) {
        //     values_color[ v ] = new THREE.Color(THREE.ColorKeywords.black);
        //     values_color[ v ].set( 0xea4f1c );
        //     attributes.customOpacity.value[ v ] = 0.1;
        // }

        var squareMesh = new THREE.Mesh( squareGeom, shaderMaterial );

        squareMesh.position.set( x - radius/2, y, z - radius/2);
        squareMesh.rotation.set( rotx, roty, rotz );
        squareMesh.scale.set( scalar, scalar, scalar );

        squareMesh.userData = { id: id, title: title, authors: authors, colour: fillColor, clicked: false, cites: numCites, numAuthors: numAuthors };
        squareMesh.name = id;

        articleObj.add( squareMesh );
        articleObjects.push( squareMesh );
    }

    function drawTermDiamond( size, fillColor, x, y, z,term, articleIndices ) {
        var extrudeSettings = { amount: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 }

        var rect = new THREE.Shape();
        rect.moveTo(0, 0);
        rect.lineTo(0, size);
        rect.lineTo(size, size);
        rect.lineTo(size, 0);
        rect.lineTo (0, 0);

        var rectGeom = new THREE.ExtrudeGeometry( rect, extrudeSettings );
        var material = new THREE.MeshPhongMaterial( { color: fillColor });

        var rectMesh = new THREE.Mesh( rectGeom, material );
        rectMesh.material.side = THREE.DoubleSide;

        rectMesh.name = term;
        rectMesh.userData = { id: term, articleIndices: articleIndices }

        rectMesh.position.set( x , y, z );
        rectMesh.rotation.set( Math.PI/2, 0, Math.PI/4 );

        //var edge = new THREE.EdgesHelper( rectMesh, fillColor );

        //scene.add( rectMesh );
        termObj.add( rectMesh );
        termObjects.push( rectMesh );

    }

    function makeCircleGeometryLinePieces(radius, segments) {
        var geometry = new THREE.Geometry();    
        var segmentStep = (1 / segments) * 2 * Math.PI;
        var theta = 0;

        for(var i = 0; i <= segments - 1; i++) {
            geometry.vertices.push(new THREE.Vector3( Math.cos( theta ) * radius, 0, Math.sin( theta ) * radius ) )
            theta += segmentStep;
            geometry.vertices.push(new THREE.Vector3( Math.cos( theta ) * radius, 0, Math.sin( theta ) * radius ) ); 
        }
        return geometry;
    }



    var circleMatrix = new THREE.Matrix4();
    var circlePositionVector = new THREE.Vector3();
    var circleGeometry = makeCircleGeometryLinePieces(1, 24);

    function drawCirclePoints ( mergedGeom, radius, x, y, z) {
        circlePositionVector.set(x, y, z);
        circleMatrix.makeScale(radius, radius, radius);
        circleMatrix.setPosition(circlePositionVector);
        mergedGeom.merge(circleGeometry, circleMatrix);
    }

    function drawCirclePointsOld ( mergedGeom, fillColor, strokeColor, radius, x, y, z, rotx, roty, rotz, scalar ) {


        var circShape = new THREE.Shape();
        circShape.moveTo(radius, 0);
        circShape.absarc(0, 0, radius, 0, Math.PI*2, false);

        var circPath = new THREE.Path();
        circPath.moveTo(radius - 0.1, 0);
        circPath.absarc(0, 0, radius - 0.2, 0, Math.PI*2, true); 
        
        circShape.holes.push( circPath );

        //var points = circShape.createSpacedPointsGeometry(12);
        //var points2 = circShape.createPointsGeometry();

        var extrudeSettings = { amount: 1, bevelEnabled: false};
        var geometry = new THREE.ExtrudeGeometry( circShape, extrudeSettings );

    var outline = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: strokeColor, side: THREE.DoubleSide } ) );

        outline.position.set( x, y, z);
        outline.rotation.set( rotx, roty, rotz );
        outline.scale.set( scalar, scalar, scalar );
        //THREE.GeometryUtils.merge(geometry, outline);
        //scene.add( outline );
        outline.updateMatrix();

//  
        mergedGeom.merge( outline.geometry, outline.matrix );
        return mergedGeom;
    }

    function drawCircle (mergedGeom, x, y, z, radius, segments, fillColor, strokeColor, id, title, authors) {
        //draw top circle
        //var articleObj = new THREE.Object3D();
        
        //var material = new THREE.LineBasicMaterial( { color: fillColor, linewidth: 3 });

        // var fillMaterial = new THREE.LineBasicMaterial( { color: fillColor } );
        // var strokeMaterial = new THREE.LineBasicMaterial( { color: strokeColor, linewidth: 3 } );

        // var multiCircle = new THREE.SceneUtils.createMultiMaterialObject( circleGeometry, [fillMaterial, strokeMaterial] );

        // multiCircle.userData = { id: id, title: title, authors: authors, colour: fillColor };
        // multiCircle.position.set(x, y, z);
        // multiCircle.name = id;
        // multiCircle.rotation.set(Math.PI/2,0,0);

        //drawCirclePoints(fillColor, strokeColor, radius, x, y, z, Math.PI/2, 0, 0, 1);
        //drawShaderCircle(fillColor, strokeColor, radius * 2, 2.0, x, y, z, Math.PI/2, 0, 0, 1, id, title, authors);




        drawCirclePoints ( mergedGeom, fillColor, strokeColor, radius, x, y, z, Math.PI/2, 0, 0, 1 );

        //scene.add(multiCircle);
        //articleObj.add(multiCircle);

        // var topCircle = new THREE.Mesh( circleGeometry, material );
        // //make backside of circle visible
        // topCircle.material.side = THREE.DoubleSide;

        // topCircle.userData = { id: id, title: title, authors: authors, colour: fillColor, clicked: false };
        // topCircle.position.set(x, y, z);
        // topCircle.name = id;
        // topCircle.rotation.set(Math.PI/2,0,0);

        //scene.add( topCircle );
        //articleObj.add( topCircle );
        //articleObjects.push( topCircle );

        //draw stroke circle
        // var outlineShape = new THREE.Shape();


        // var circleGeometry = new THREE.CircleGeometry( radius, segments );
        // var outlineMaterial = new THREE.MeshBasicMaterial( { color: strokeColor, side: THREE.BackSide });
        // var outlineMesh = new THREE.Mesh( circleGeometry, outlineMaterial );
        // outlineMesh.material.side = THREE.DoubleSide;
        // outlineMesh.userData = { id: id, title: title, authors: authors, colour: strokeColor };
        // outlineMesh.position.set(x, y - 0.1, z);
        // outlineMesh.rotation.set(Math.PI/2,0,0);
        // outlineMesh.scale.multiplyScalar(1.2);
        // articleObj.add( outlineMesh );

        //articleObjects.push( outlineMesh );
    }

    function drawTetrahedron(x, y, z, radius, fillColor, term, articleIndices ) {

        var material = new THREE.LineBasicMaterial( { color: fillColor });
        var tetra = new THREE.Mesh( new THREE.TetrahedronGeometry( radius, 0 ), material );
        tetra.material.side = THREE.DoubleSide;
        tetra.name = term;
        tetra.userData = { id: term, articleIndices: articleIndices }
        tetra.position.set( x, y, z );
        scene.add( tetra );
        termObj.add( tetra );
        termObjects.push( tetra );

        //console.log("DRAW TETRA");
    }

    function drawGrid() {
        var gridColor = new THREE.Color(0xd9f7ad);
        var blackColor = new THREE.Color(0x000000);
        var gridColorAlpha = gridColor.lerp(blackColor, 0.75);

        var gridXZ_1 = new THREE.GridHelper(1500, 200);
        gridXZ_1.setColors( gridColorAlpha, gridColorAlpha );
        //gridXZ_1.position.set(340, 0, 760);
        //gridXZ_1.position.set(0, 0, 0);
        //scene.add(gridXZ_1);

        var gridXZ_2 = new THREE.GridHelper(1500, 200);
        gridXZ_2.name = "lowerGrid";
        gridXZ_2.setColors( gridColorAlpha, gridColorAlpha );
        gridXZ_2.position.set(500, termOffset, 800);
        //gridXZ_2.position.set(500, 0, 800);
        scene.add(gridXZ_2);
    }

    function loadArticles() {
        var request = $.ajax({
            type: "GET",
            url: "data/articlesNewInfo4.json",
            dataType: 'JSON',
            contentType: 'application/json'
        })
            .done(function(data) {
                console.log( "success loading articles" );         
                //console.log(data);

                parseArticle(data);

                //console.log(articles.length);
                //loadTerms(articles);

            })
            .fail(function() {
                console.log( "error" );
            });

        //

    }

    function parseArticle(data) {
        for (d in data.articles) {
            var item = data.articles[d];

            tempArticle = {};
            tempArticle.id = item.id;
            tempArticle.x = item.x;
            tempArticle.y = item.y;
            tempArticle.z = item.z;
            tempArticle.radius = item.radius;
            tempArticle.title = item.title;
            tempArticle.published = item.published;
            tempArticle.authors = item.authors;
            tempArticle.numAuthors = item.numAuthors;
            tempArticle.numCites = item.numCites;
            tempArticle.numRefs = item.numRefs;

            articles.push(tempArticle);
        }

        console.log("finished parsing articles - decide when to drawArticles");

        //drawArticles(articles);
        loadTerms(articles);
    }

    function drawArticles( array ) {
        var mergedGeomPub = new THREE.Geometry();
        var mergedGeomUnPub = new THREE.Geometry();

        for (var i = 0; i < array.length; i++) {

            var colorAuthorMin = new THREE.Color(0x3f348c);
            var colorAuthorMax2 = new THREE.Color(0xf47f31);
            var colorAuthorMax3 = new THREE.Color(0xd8301e);

            var mappedAuthor = map_range(array[i].numAuthors, 1, 5, 0, 1);
            var fillColor = colorAuthorMin.lerp(colorAuthorMax2, mappedAuthor);

            var authorStr;

            if (array[i].numAuthors > 5 ) {
                fillColor = colorAuthorMax2;

                for (var j = 0; j < 5; j++ ) {
                    authorStr += array[i].authors[j] + ", ";
                }

                authorStr += " ...";

            } else {
                authorStr = array[i].authors.join(", ");
            }

            if (array[i].numAuthors > 800) {
                fillColor = colorAuthorMax3;
            }

            var strokeColor;
            if (array[i].published) {
                strokeColor = new THREE.Color(0x00dbbb);
                drawCirclePoints ( mergedGeomPub, array[i].radius * .99, array[i].x, array[i].z, array[i].y);
            } else {
                strokeColor = new THREE.Color(0x5309aa);
            drawCirclePoints ( mergedGeomUnPub, array[i].radius * .99, array[i].x, array[i].z, array[i].y);
            }
            drawShaderCircle(fillColor, strokeColor, array[i].radius * 2, 2.0, array[i].x, array[i].z, array[i].y, Math.PI/2, 0, 0, 1, array[i].id, array[i].title, authorStr, array[i].numAuthors, array[i].numCites);
            //drawCircle(array[i].x * -2, array[i].z * 0.25, array[i].y * 2, array[i].radius * 0.2, 64, fillColor, strokeColor);
            

        }

        var totalCirclePub = new THREE.Line(mergedGeomPub, new THREE.LineBasicMaterial( { color : 0x00dbbb}), THREE.LinePieces);
        var totalCircleUnPub = new THREE.Line(mergedGeomUnPub, new THREE.LineBasicMaterial( { color : 0x5309aa }), THREE.LinePieces);
        
        scene.add( totalCirclePub );
        scene.add( totalCircleUnPub );
        //console.log("size of articleObjects array: " + articleObjects.length);
        drawGrid();
        
        $("#loader").fadeOut( function() {
            startIntro(); //TOUR STARTS AFTER EVERYTHING LOADS
        });
    }

    function loadTerms(articleArray) {
        var request = $.ajax({
            type: "GET",
            url: "data/termNewInfo2.json",
            dataType: 'JSON',
            contentType: 'application/json'
        })
        .done(function(data) {
            console.log( "success loading terms" );         
            //console.log(data);

            parseTerm(data, articleArray);

            // $("#loader").fadeOut();
            //drawSplines(articles, terms);
 
        })
        .fail(function() {
            console.log( "error" );
        });
    }

    function parseTerm( data, articleArray ) {

        for (d in data.terms) {
            var item = data.terms[d];
            var articleIndexArray = [];
            tempTerm = {};
            tempTerm.term = item.term;
            tempTerm.x = item.x;
            tempTerm.y = item.y;
            tempTerm.z = item.z;
            tempTerm.articles = item.articles;
            tempTerm.connections = item.connections;


            for (var i = 0; i < item.articles.length; i++) {
                //console.log("term article: " + item.articles[i]);
                for (var j = 0; j < articleArray.length; j++) {
                    if(item.articles[i] === articleArray[j].id) {
                        //console.log("article id: " + articleArray[j].id);
                        articleIndexArray.push(j);
                        break;
                    }
                }

            }

            tempTerm.articleIndex = articleIndexArray;

            terms.push(tempTerm);


        }

        // console.log(terms);
        // console.log(terms.length);
        console.log("finished parsing terms - decide when to drawTerms");
        drawArticles(articles);
        drawTerms(terms);

    }

    function drawTerms ( termArray, articleArray ) {
        for (var i = 0; i < termArray.length; i++) {
            var t1 = termArray[i];
            // console.log("t1: " );
            // console.log(t1.connections);

            var fillColor = new THREE.Color ( 0xea4f1c );

            drawTermDiamond (20, fillColor, t1.x, termOffset + 2 * t1.z, t1.y, t1.term, t1.articleIndex);

            //console.log("DRAW CIRCLE");
            //console.log(t1.term + " - x: " + t1.x + " z: " + t1.y  + " y: " + t1.z);
            //console.log(termObj);
            var title = toTitleCase(t1.term);

            var spritey = makeTextSprite(" " + title, 
                   { fontsize: 100, 
                        fontface: "Georgia", 
                        //borderColor: {r:234, g:79, b:28, a:1.0}, 
                        borderColor: {r: 107, g: 107, b: 107, a:1.0},
                        backgroundColor: {r: 55, g:55, b:55, a:0.9} } );
            spritey.position.set(t1.x , termOffset + 2*t1.z - 50 , t1.y);
            spriteObj.add( spritey );

            //for network lines between terms (seem like there are too many being drawn, or not transparent enough)
            //this is currently disabled for legibility
            /*
            for (t in t1.connections) {
                var connect1 = t1.connections[t];
                var connect1Id = t1.connections[t].id;
                console.log("t1 id: " + connect1Id);

                for (var j = i + 1; j < terms.length; j++) {
                    var t2 = terms[j];
                    //console.log("t2: " + t2.connections.length);

                    for(n in t2.connections) {
                        var connect2 = t2.connections[n];
                        var connect2Id = t2.connections[n].id;
                        console.log("t2 id: " + connect2Id);
                    }
                    if (connect1Id === connect2Id) {
                        console.log("DRAW LINE");
                        //drawLine(t1.x * 0.1, t1.z * 0.1, t1.y * 0.1, t2.x * 0.1, t2.z * 0.1, t2.y * 0.1, 0xff0000);
                         //drawLine(t1.x, termOffset + 2 * t1.z, t1.y, t2.x, termOffset + 2 * t2.z, t2.y, 0xff0000);

                    }
                }
            }
             console.log("____________________");
            */
        }
        spriteObj.name = "sprites";
    }

    function drawSplines( article, term, name ) {

        //shader stuff

        attributes = {
            customColor: {    type: 'c', value: [] },
            customOpacity: { type: 'f', value: []}
        };

        var shaderMaterial = new THREE.ShaderMaterial( {
            attributes:     attributes,
            vertexShader:   document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            blending:       THREE.NormalBlending,
            depthTest:      true,
            transparent:    true,
            side:           THREE.DoubleSide,
            linewidth:      2
        });

        var slideA = 0.8;
        var slideB = 1 - slideA;

        var start = new THREE.Vector3(article.x, article.y, article.z);
        var end = new THREE.Vector3(term.x, term.y, term.z);
        var startMid = new THREE.Vector3(slideA * start.x + slideB * end.x, slideA * start.y + slideB * end.y, start.z -.25 * Math.abs(end.z - start.z));
        var endMid = new THREE.Vector3(slideA * end.x + slideB * start.x, slideA * end.y + slideB * start.y, end.z + .35 * Math.abs(end.z - start.z));

        //Create a closed bent a sine-like wave
        var curve = new THREE.SplineCurve3( [
            // new THREE.Vector3(start.x, start.y - 20, start.z),
            start,
            startMid,
            endMid,
            end
            // new THREE.Vector3(end.x, end.y + 20, end.z)
        ] );

        var geometry = new THREE.Geometry();
        geometry.vertices = curve.getPoints( 30 );


        // var splineColor = new THREE.Color(0xea4f1c);
        // var blackColor = new THREE.Color(0x000000);
        // var lerpedSplineColor = splineColor.lerp(blackColor, 0.66);

        // var material = new THREE.LineBasicMaterial( { color : lerpedSplineColor } );

        //shader stuff
        var values_color = attributes.customColor.value;
        for ( var v = 0; v < geometry.vertices.length; v++ ) {
            values_color[ v ] = new THREE.Color(THREE.ColorKeywords.black);
            values_color[ v ].set( 0xea4f1c );
            attributes.customOpacity.value[ v ] = 0.1;
        }

        //Create the final Object3d to add to the scene
        var splineObject = new THREE.Line( geometry, shaderMaterial );
 
        splineObj.add( splineObject );

        //scene.add( splineObject );
    }

    function drawLine(x1, y1, z1, x2, y2, z2, strokeColor) {

        //shader stuff

        attributes = {
            customColor: {    type: 'c', value: [] },
            customOpacity: { type: 'f', value: []}
        };

        var shaderMaterial = new THREE.ShaderMaterial( {
            attributes:     attributes,
            vertexShader:   document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            blending:       THREE.NormalBlending,
            depthTest:      true,
            transparent:    true,
            side:           THREE.DoubleSide,
            linewidth:      2
        });


        // var material = new THREE.LineBasicMaterial({
        //     color: strokeColor
        // });

        var geometry = new THREE.Geometry();
        geometry.vertices.push(
            new THREE.Vector3( x1, y1, z1 ),
            new THREE.Vector3( x2, y2, z2 )
        );

        //shader stuff
        var values_color = attributes.customColor.value;
        for ( var v = 0; v < geometry.vertices.length; v++ ) {
            values_color[ v ] = new THREE.Color(THREE.ColorKeywords.black);
            values_color[ v ].set( 0xea4f1c );
            attributes.customOpacity.value[ v ] = 0.25;
        }


        var line = new THREE.Line( geometry, shaderMaterial );
        scene.add( line );
    }

    

    // function for drawing rounded rectangles
    function roundRect(ctx, x, y, w, h, r)
    {
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.lineTo(x+w-r, y);
        ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r);
        ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r);
        ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    function rect(ctx, x, y, w, h) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+w, y);
        ctx.lineTo(x+w, y+h);
        ctx.lineTo(x, y+h);
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    function makeTextSprite( message, parameters ) {
        var group = new THREE.Object3D();

        if ( parameters === undefined ) parameters = {};

        var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Georgia";
        var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
        var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
        var borderColor = parameters.hasOwnProperty("borderColor") ?parameters["borderColor"] : { r:255, g:255, b:255, a:1.0 };
        var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?parameters["backgroundColor"] : { r:0, g:0, b:0, a:1.0 };
        var textColor = parameters.hasOwnProperty("textColor") ?parameters["textColor"] : { r:255, g:255, b:255, a:1.0 };

        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = 2160;
        canvas.height = 200;
        var context = canvas.getContext('2d');
        context.font = "Bold " + fontsize + "px " + fontface;
        var metrics = context.measureText( message );
        console.log(message);
        console.log("metrics: " + metrics.width);
        var textWidth = metrics.width;

        //var textWidth = 500;
        context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

        context.lineWidth = borderThickness;
        //roundRect(context, borderThickness/2, borderThickness/2, (textWidth + borderThickness) * 1.05, fontsize * 1.4 + borderThickness, 8);

        rect(context, borderThickness/2 + (canvas.width/2) - (textWidth/2), borderThickness/2 , (textWidth * 1.025 + borderThickness), fontsize * 1.3 + borderThickness);

        context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";
        context.fillText( message, borderThickness + (canvas.width/2) - (textWidth/2), (fontsize));

        //console.log('textWidth: ' + textWidth);

        var labelTexture = new THREE.Texture(canvas); //label texture
        labelTexture.needsUpdate = true;

        var texture = new THREE.Texture(context); //white texture
        texture.needsUpdate = true;

        var spriteMaterial = new THREE.SpriteMaterial( { map: texture });
        var sprite = new THREE.Sprite( spriteMaterial );
        sprite.scale.set(460, fontsize, fontsize);

        var spriteMaterial2 = new THREE.SpriteMaterial( { map: labelTexture });
        var labelsprite = new THREE.Sprite( spriteMaterial2);
        labelsprite.scale.set(800, fontsize * 0.9, fontsize);

        labelsprite.userData = { width: textWidth };
        group.name = "labelSprite";

        //group.add(sprite);
        group.add(labelsprite);

        //return labelsprite;
        return group;
    }

    //UTIL FUNCTIONS
    function map_range(value, low1, high1, low2, high2) {
        return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    }

    function toTitleCase(str) {
        str = str.replace(/^\s+/, '');
        str = str.charAt(0).toUpperCase() + str.substr(1);
        return str;
    }

    function onWindowResize() {
        console.log("resizing window");

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

</script>



</body>
</html>